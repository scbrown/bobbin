{
  "task_id": "ruff-004",
  "approach": "with-bobbin",
  "attempt": 0,
  "status": "completed",
  "timestamp": "2026-02-10T20:48:35.524787+00:00",
  "task": {
    "repo": "astral-sh/ruff",
    "commit": "ceb876b82300bd237d11e3eb77c46fcf3d3afe85",
    "test_command": "cargo test -p ruff_linter -- PYI034",
    "language": "rust",
    "difficulty": "easy"
  },
  "agent_result": {
    "exit_code": 0,
    "duration_seconds": 229.31,
    "timed_out": false
  },
  "test_result": {
    "passed": true,
    "total": 0,
    "failures": 0,
    "parsed": {
      "framework": "pytest",
      "passed": 0,
      "failed": 0,
      "skipped": 0,
      "total": 0
    }
  },
  "diff_result": {
    "file_precision": 0.3333,
    "file_recall": 0.3333,
    "f1": 0.3333,
    "files_touched": [
      "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi",
      "crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs",
      "crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap"
    ],
    "ground_truth_files": [
      "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py",
      "crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs",
      "crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap"
    ],
    "exact_file_match": false
  },
  "agent_diff": "diff --git a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi\nindex b22f76798b..f1c7948a4f 100644\n--- a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi\n+++ b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi\n@@ -216,6 +216,11 @@ def __imul__(self, other: Any) -> list[str]: ...\n class UsesStringizedAnnotations:\n     def __iadd__(self, other: \"UsesStringizedAnnotations\") -> \"typing.Self\": ...\n \n+class UsesStringizedAnnotationsForwardRef:\n+    def __new__(cls) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+    def __enter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+    async def __aenter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+\n \n class NonGeneric1(tuple):\n     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\nindex d3b2f75b2d..4791c089bd 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n@@ -182,7 +182,7 @@ pub(crate) fn non_self_return_type(\n \n     if is_async {\n         if name == \"__aenter__\"\n-            && is_name(returns, &class_def.name)\n+            && is_name_or_stringized_name(returns, &class_def.name, checker)\n             && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -198,7 +198,7 @@ pub(crate) fn non_self_return_type(\n         return;\n     }\n \n-    if is_name(returns, &class_def.name) {\n+    if is_name_or_stringized_name(returns, &class_def.name, checker) {\n         if matches!(name, \"__enter__\" | \"__new__\") && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -334,6 +334,11 @@ fn is_self(expr: &ast::Expr, checker: &Checker) -> bool {\n     })\n }\n \n+/// Return `true` if the given expression (stringized or not) resolves to the given name.\n+fn is_name_or_stringized_name(expr: &ast::Expr, name: &str, checker: &Checker) -> bool {\n+    checker.match_maybe_stringized_annotation(expr, |expr| is_name(expr, name))\n+}\n+\n /// Return `true` if the given class extends `collections.abc.Iterator`.\n fn subclasses_iterator(class_def: &ast::StmtClassDef, semantic: &SemanticModel) -> bool {\n     analyze::class::any_qualified_base_class(class_def, semantic, &|qualified_name| {\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap\nindex 29c91b9a77..f7c03a50fa 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap\n@@ -1,5 +1,6 @@\n ---\n source: crates/ruff_linter/src/rules/flake8_pyi/mod.rs\n+assertion_line: 137\n ---\n PYI034 [*] `__new__` methods in classes like `Bad` usually return `self` at runtime\n   --> PYI034.pyi:20:9\n@@ -198,258 +199,317 @@ help: Use `Self` as return type\n 149 |     def __aiter__(\n note: This is an unsafe fix and may change runtime behavior\n \n-PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime\n-   --> PYI034.pyi:221:9\n+PYI034 [*] `__new__` methods in classes like `UsesStringizedAnnotationsForwardRef` usually return `self` at runtime\n+   --> PYI034.pyi:220:9\n     |\n-220 | class NonGeneric1(tuple):\n-221 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+219 | class UsesStringizedAnnotationsForwardRef:\n+220 |     def __new__(cls) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n     |         ^^^^^^^\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+221 |     def __enter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+222 |     async def __aenter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n     |\n help: Use `Self` as return type\n+217 |     def __iadd__(self, other: \"UsesStringizedAnnotations\") -> \"typing.Self\": ...\n 218 | \n-219 | \n-220 | class NonGeneric1(tuple):\n-    -     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n-221 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+219 | class UsesStringizedAnnotationsForwardRef:\n+    -     def __new__(cls) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+220 +     def __new__(cls) -> typing.Self: ...  # Y034\n+221 |     def __enter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+222 |     async def __aenter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+223 | \n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__enter__` methods in classes like `UsesStringizedAnnotationsForwardRef` usually return `self` at runtime\n+   --> PYI034.pyi:221:9\n+    |\n+219 | class UsesStringizedAnnotationsForwardRef:\n+220 |     def __new__(cls) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+221 |     def __enter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+    |         ^^^^^^^^^\n+222 |     async def __aenter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+    |\n+help: Use `Self` as return type\n+218 | \n+219 | class UsesStringizedAnnotationsForwardRef:\n+220 |     def __new__(cls) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+    -     def __enter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+221 +     def __enter__(self) -> typing.Self: ...  # Y034\n+222 |     async def __aenter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n 223 | \n-224 | class NonGeneric2(tuple):\n+224 | \n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__aenter__` methods in classes like `UsesStringizedAnnotationsForwardRef` usually return `self` at runtime\n+   --> PYI034.pyi:222:15\n+    |\n+220 |     def __new__(cls) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+221 |     def __enter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+222 |     async def __aenter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+    |               ^^^^^^^^^^\n+    |\n+help: Use `Self` as return type\n+219 | class UsesStringizedAnnotationsForwardRef:\n+220 |     def __new__(cls) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+221 |     def __enter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+    -     async def __aenter__(self) -> \"UsesStringizedAnnotationsForwardRef\": ...  # Y034\n+222 +     async def __aenter__(self) -> typing.Self: ...  # Y034\n+223 | \n+224 | \n+225 | class NonGeneric1(tuple):\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime\n+   --> PYI034.pyi:226:9\n+    |\n+225 | class NonGeneric1(tuple):\n+226 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+    |         ^^^^^^^\n+227 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+    |\n+help: Use `Self` as return type\n+223 | \n+224 | \n+225 | class NonGeneric1(tuple):\n+    -     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+226 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...\n+227 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+228 | \n+229 | class NonGeneric2(tuple):\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__enter__` methods in classes like `NonGeneric1` usually return `self` at runtime\n-   --> PYI034.pyi:222:9\n+   --> PYI034.pyi:227:9\n     |\n-220 | class NonGeneric1(tuple):\n-221 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+225 | class NonGeneric1(tuple):\n+226 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+227 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n     |         ^^^^^^^^^\n-223 |\n-224 | class NonGeneric2(tuple):\n+228 |\n+229 | class NonGeneric2(tuple):\n     |\n help: Use `Self` as return type\n-219 | \n-220 | class NonGeneric1(tuple):\n-221 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+224 | \n+225 | class NonGeneric1(tuple):\n+226 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n     -     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-222 +     def __enter__(self) -> typing.Self: ...\n-223 | \n-224 | class NonGeneric2(tuple):\n-225 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+227 +     def __enter__(self) -> typing.Self: ...\n+228 | \n+229 | class NonGeneric2(tuple):\n+230 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__new__` methods in classes like `NonGeneric2` usually return `self` at runtime\n-   --> PYI034.pyi:225:9\n+   --> PYI034.pyi:230:9\n     |\n-224 | class NonGeneric2(tuple):\n-225 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+229 | class NonGeneric2(tuple):\n+230 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n     |         ^^^^^^^\n-226 |\n-227 | class Generic1[T](list):\n+231 |\n+232 | class Generic1[T](list):\n     |\n help: Use `Self` as return type\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-223 | \n-224 | class NonGeneric2(tuple):\n+227 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+228 | \n+229 | class NonGeneric2(tuple):\n     -     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n-225 +     def __new__(cls) -> typing.Self: ...\n-226 | \n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+230 +     def __new__(cls) -> typing.Self: ...\n+231 | \n+232 | class Generic1[T](list):\n+233 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__new__` methods in classes like `Generic1` usually return `self` at runtime\n-   --> PYI034.pyi:228:9\n+   --> PYI034.pyi:233:9\n     |\n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+232 | class Generic1[T](list):\n+233 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n     |         ^^^^^^^\n-229 |     def __enter__(self: Generic1) -> Generic1: ...\n+234 |     def __enter__(self: Generic1) -> Generic1: ...\n     |\n help: Use `Self` as return type\n-225 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n-226 | \n-227 | class Generic1[T](list):\n-    -     def __new__(cls: type[Generic1]) -> Generic1: ...\n-228 +     def __new__(cls) -> typing.Self: ...\n-229 |     def __enter__(self: Generic1) -> Generic1: ...\n-230 | \n+230 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n 231 | \n+232 | class Generic1[T](list):\n+    -     def __new__(cls: type[Generic1]) -> Generic1: ...\n+233 +     def __new__(cls) -> typing.Self: ...\n+234 |     def __enter__(self: Generic1) -> Generic1: ...\n+235 | \n+236 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic1` usually return `self` at runtime\n-   --> PYI034.pyi:229:9\n+   --> PYI034.pyi:234:9\n     |\n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n-229 |     def __enter__(self: Generic1) -> Generic1: ...\n+232 | class Generic1[T](list):\n+233 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+234 |     def __enter__(self: Generic1) -> Generic1: ...\n     |         ^^^^^^^^^\n     |\n help: Use `Self` as return type\n-226 | \n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n-    -     def __enter__(self: Generic1) -> Generic1: ...\n-229 +     def __enter__(self) -> typing.Self: ...\n-230 | \n 231 | \n-232 | ### Correctness of typevar-likes are not verified.\n+232 | class Generic1[T](list):\n+233 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+    -     def __enter__(self: Generic1) -> Generic1: ...\n+234 +     def __enter__(self) -> typing.Self: ...\n+235 | \n+236 | \n+237 | ### Correctness of typevar-likes are not verified.\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic2` usually return `self` at runtime\n-   --> PYI034.pyi:239:9\n+   --> PYI034.pyi:244:9\n     |\n-238 | class Generic2(Generic[T]):\n-239 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+243 | class Generic2(Generic[T]):\n+244 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n     |         ^^^^^^^\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n+245 |     def __enter__(self: Generic2) -> Generic2: ...\n     |\n help: Use `Self` as return type\n-236 | Ts = TypeVarTuple('foo')\n-237 | \n-238 | class Generic2(Generic[T]):\n+241 | Ts = TypeVarTuple('foo')\n+242 | \n+243 | class Generic2(Generic[T]):\n     -     def __new__(cls: type[Generic2]) -> Generic2: ...\n-239 +     def __new__(cls) -> typing.Self: ...\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n+244 +     def __new__(cls) -> typing.Self: ...\n+245 |     def __enter__(self: Generic2) -> Generic2: ...\n+246 | \n+247 | class Generic3(tuple[*Ts]):\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic2` usually return `self` at runtime\n-   --> PYI034.pyi:240:9\n+   --> PYI034.pyi:245:9\n     |\n-238 | class Generic2(Generic[T]):\n-239 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n+243 | class Generic2(Generic[T]):\n+244 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+245 |     def __enter__(self: Generic2) -> Generic2: ...\n     |         ^^^^^^^^^\n-241 |\n-242 | class Generic3(tuple[*Ts]):\n+246 |\n+247 | class Generic3(tuple[*Ts]):\n     |\n help: Use `Self` as return type\n-237 | \n-238 | class Generic2(Generic[T]):\n-239 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+242 | \n+243 | class Generic2(Generic[T]):\n+244 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n     -     def __enter__(self: Generic2) -> Generic2: ...\n-240 +     def __enter__(self) -> typing.Self: ...\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+245 +     def __enter__(self) -> typing.Self: ...\n+246 | \n+247 | class Generic3(tuple[*Ts]):\n+248 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic3` usually return `self` at runtime\n-   --> PYI034.pyi:243:9\n+   --> PYI034.pyi:248:9\n     |\n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+247 | class Generic3(tuple[*Ts]):\n+248 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n     |         ^^^^^^^\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n+249 |     def __enter__(self: Generic3) -> Generic3: ...\n     |\n help: Use `Self` as return type\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n+245 |     def __enter__(self: Generic2) -> Generic2: ...\n+246 | \n+247 | class Generic3(tuple[*Ts]):\n     -     def __new__(cls: type[Generic3]) -> Generic3: ...\n-243 +     def __new__(cls) -> typing.Self: ...\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n+248 +     def __new__(cls) -> typing.Self: ...\n+249 |     def __enter__(self: Generic3) -> Generic3: ...\n+250 | \n+251 | class Generic4(collections.abc.Callable[P, ...]):\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic3` usually return `self` at runtime\n-   --> PYI034.pyi:244:9\n+   --> PYI034.pyi:249:9\n     |\n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n+247 | class Generic3(tuple[*Ts]):\n+248 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+249 |     def __enter__(self: Generic3) -> Generic3: ...\n     |         ^^^^^^^^^\n-245 |\n-246 | class Generic4(collections.abc.Callable[P, ...]):\n+250 |\n+251 | class Generic4(collections.abc.Callable[P, ...]):\n     |\n help: Use `Self` as return type\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+246 | \n+247 | class Generic3(tuple[*Ts]):\n+248 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n     -     def __enter__(self: Generic3) -> Generic3: ...\n-244 +     def __enter__(self) -> typing.Self: ...\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+249 +     def __enter__(self) -> typing.Self: ...\n+250 | \n+251 | class Generic4(collections.abc.Callable[P, ...]):\n+252 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic4` usually return `self` at runtime\n-   --> PYI034.pyi:247:9\n+   --> PYI034.pyi:252:9\n     |\n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+251 | class Generic4(collections.abc.Callable[P, ...]):\n+252 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n     |         ^^^^^^^\n-248 |     def __enter__(self: Generic4) -> Generic4: ...\n+253 |     def __enter__(self: Generic4) -> Generic4: ...\n     |\n help: Use `Self` as return type\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n+249 |     def __enter__(self: Generic3) -> Generic3: ...\n+250 | \n+251 | class Generic4(collections.abc.Callable[P, ...]):\n     -     def __new__(cls: type[Generic4]) -> Generic4: ...\n-247 +     def __new__(cls) -> typing.Self: ...\n-248 |     def __enter__(self: Generic4) -> Generic4: ...\n-249 | \n-250 | from some_module import PotentialTypeVar\n+252 +     def __new__(cls) -> typing.Self: ...\n+253 |     def __enter__(self: Generic4) -> Generic4: ...\n+254 | \n+255 | from some_module import PotentialTypeVar\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic4` usually return `self` at runtime\n-   --> PYI034.pyi:248:9\n+   --> PYI034.pyi:253:9\n     |\n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n-248 |     def __enter__(self: Generic4) -> Generic4: ...\n+251 | class Generic4(collections.abc.Callable[P, ...]):\n+252 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+253 |     def __enter__(self: Generic4) -> Generic4: ...\n     |         ^^^^^^^^^\n-249 |\n-250 | from some_module import PotentialTypeVar\n+254 |\n+255 | from some_module import PotentialTypeVar\n     |\n help: Use `Self` as return type\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+250 | \n+251 | class Generic4(collections.abc.Callable[P, ...]):\n+252 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n     -     def __enter__(self: Generic4) -> Generic4: ...\n-248 +     def __enter__(self) -> typing.Self: ...\n-249 | \n-250 | from some_module import PotentialTypeVar\n-251 | \n+253 +     def __enter__(self) -> typing.Self: ...\n+254 | \n+255 | from some_module import PotentialTypeVar\n+256 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic5` usually return `self` at runtime\n-   --> PYI034.pyi:253:9\n+   --> PYI034.pyi:258:9\n     |\n-252 | class Generic5(list[PotentialTypeVar]):\n-253 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+257 | class Generic5(list[PotentialTypeVar]):\n+258 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n     |         ^^^^^^^\n-254 |     def __enter__(self: Generic5) -> Generic5: ...\n+259 |     def __enter__(self: Generic5) -> Generic5: ...\n     |\n help: Use `Self` as return type\n-250 | from some_module import PotentialTypeVar\n-251 | \n-252 | class Generic5(list[PotentialTypeVar]):\n-    -     def __new__(cls: type[Generic5]) -> Generic5: ...\n-253 +     def __new__(cls) -> typing.Self: ...\n-254 |     def __enter__(self: Generic5) -> Generic5: ...\n-255 | \n+255 | from some_module import PotentialTypeVar\n 256 | \n+257 | class Generic5(list[PotentialTypeVar]):\n+    -     def __new__(cls: type[Generic5]) -> Generic5: ...\n+258 +     def __new__(cls) -> typing.Self: ...\n+259 |     def __enter__(self: Generic5) -> Generic5: ...\n+260 | \n+261 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic5` usually return `self` at runtime\n-   --> PYI034.pyi:254:9\n+   --> PYI034.pyi:259:9\n     |\n-252 | class Generic5(list[PotentialTypeVar]):\n-253 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n-254 |     def __enter__(self: Generic5) -> Generic5: ...\n+257 | class Generic5(list[PotentialTypeVar]):\n+258 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+259 |     def __enter__(self: Generic5) -> Generic5: ...\n     |         ^^^^^^^^^\n     |\n help: Use `Self` as return type\n-251 | \n-252 | class Generic5(list[PotentialTypeVar]):\n-253 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n-    -     def __enter__(self: Generic5) -> Generic5: ...\n-254 +     def __enter__(self) -> typing.Self: ...\n-255 | \n 256 | \n-257 | # Test case based on issue #20781 - metaclass that triggers IsMetaclass::Maybe\n+257 | class Generic5(list[PotentialTypeVar]):\n+258 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+    -     def __enter__(self: Generic5) -> Generic5: ...\n+259 +     def __enter__(self) -> typing.Self: ...\n+260 | \n+261 | \n+262 | # Test case based on issue #20781 - metaclass that triggers IsMetaclass::Maybe\n note: This is a display-only fix and is likely to be incorrect\n",
  "ground_truth_diff": "diff --git a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\nindex b35efc3c21..37ad3d3706 100644\n--- a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n+++ b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n@@ -385,3 +385,10 @@ class MetaclassInWhichSelfCannotBeUsed7(django.db.models.base.ModelBase):\n class MetaclassInWhichSelfCannotBeUsed8(django.db.models.base.ModelBase):\n     def __new__(cls, name: builtins.str, bases: tuple, attributes: dict, /, **kw) -> MetaclassInWhichSelfCannotBeUsed8:\n         ...\n+\n+\n+class UsesStringizedForwardReferences:\n+    def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\nindex d3b2f75b2d..e74363a446 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n@@ -182,7 +182,7 @@ pub(crate) fn non_self_return_type(\n \n     if is_async {\n         if name == \"__aenter__\"\n-            && is_name(returns, &class_def.name)\n+            && is_name_or_stringized_name(returns, &class_def.name, checker)\n             && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -198,7 +198,7 @@ pub(crate) fn non_self_return_type(\n         return;\n     }\n \n-    if is_name(returns, &class_def.name) {\n+    if is_name_or_stringized_name(returns, &class_def.name, checker) {\n         if matches!(name, \"__enter__\" | \"__new__\") && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -327,6 +327,11 @@ fn is_name(expr: &ast::Expr, name: &str) -> bool {\n     id.as_str() == name\n }\n \n+/// Return `true` if the given expression resolves to the given name,\n+fn is_name_or_stringized_name(expr: &ast::Expr, name: &str, checker: &Checker) -> bool {\n+    checker.match_maybe_stringized_annotation(expr, |expr| is_name(expr, name))\n+}\n+\n /// Return `true` if the given expression resolves to `typing.Self`.\n fn is_self(expr: &ast::Expr, checker: &Checker) -> bool {\n     checker.match_maybe_stringized_annotation(expr, |expr| {\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\nindex 8893a346e1..c730e8a2b6 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n@@ -472,3 +472,77 @@ help: Use `Self` as return type\n 362 | \n 363 | # Test cases based on issue #20781 - metaclasses that triggers IsMetaclass::Maybe\n note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__new__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:391:9\n+    |\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    |         ^^^^^^^\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+388 | \n+389 | \n+390 | class UsesStringizedForwardReferences:\n+    -     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+391 +     def __new__(cls) -> typing.Self: ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__enter__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:392:9\n+    |\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    |         ^^^^^^^^^\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+389 | \n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    -     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+392 +     def __enter__(self) -> typing.Self: ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__aenter__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:393:15\n+    |\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |               ^^^^^^^^^^\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    -     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+393 +     async def __aenter__(self) -> typing.Self: ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__iadd__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:394:9\n+    |\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |         ^^^^^^^^\n+    |\n+help: Use `Self` as return type\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    -     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 +     def __iadd__(self, other) -> typing.Self: ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n",
  "project_metadata": {
    "CSS": {
      "files": 3,
      "lines": 377,
      "code": 322,
      "comments": 6,
      "blanks": 49
    },
    "Dockerfile": {
      "files": 1,
      "lines": 38,
      "code": 26,
      "comments": 7,
      "blanks": 5
    },
    "HTML": {
      "files": 2,
      "lines": 81,
      "code": 81,
      "comments": 0,
      "blanks": 0
    },
    "JavaScript": {
      "files": 2,
      "lines": 97,
      "code": 77,
      "comments": 11,
      "blanks": 9
    },
    "JSON": {
      "files": 134,
      "lines": 15716,
      "code": 15706,
      "comments": 0,
      "blanks": 10
    },
    "Jupyter Notebooks": {
      "files": 35,
      "lines": 511,
      "code": 289,
      "comments": 154,
      "blanks": 68
    },
    "Markdown": {
      "files": 391,
      "lines": 117506,
      "code": 0,
      "comments": 85634,
      "blanks": 31872
    },
    "Python": {
      "files": 3687,
      "lines": 266549,
      "code": 211732,
      "comments": 12788,
      "blanks": 42029
    },
    "Rust": {
      "files": 1743,
      "lines": 511275,
      "code": 432571,
      "comments": 25123,
      "blanks": 53581
    },
    "Shell": {
      "files": 15,
      "lines": 489,
      "code": 274,
      "comments": 143,
      "blanks": 72
    },
    "SVG": {
      "files": 28,
      "lines": 1445,
      "code": 1308,
      "comments": 71,
      "blanks": 66
    },
    "Plain Text": {
      "files": 43,
      "lines": 188649,
      "code": 0,
      "comments": 188648,
      "blanks": 1
    },
    "TOML": {
      "files": 144,
      "lines": 4323,
      "code": 3625,
      "comments": 219,
      "blanks": 479
    },
    "TSX": {
      "files": 30,
      "lines": 5526,
      "code": 4810,
      "comments": 163,
      "blanks": 553
    },
    "TypeScript": {
      "files": 14,
      "lines": 480,
      "code": 363,
      "comments": 61,
      "blanks": 56
    },
    "YAML": {
      "files": 24,
      "lines": 3705,
      "code": 3093,
      "comments": 288,
      "blanks": 324
    },
    "Total": {
      "files": 0,
      "lines": 1195029,
      "code": 687056,
      "comments": 364538,
      "blanks": 143435
    }
  },
  "bobbin_metadata": {
    "index_duration_seconds": 95.71,
    "profile": {
      "file_i/o": 0,
      "parse": 1300,
      "context": 10,
      "embed": 26242,
      "tokenize": 3488,
      "inference": 21589,
      "pooling": 368,
      "lance_delete": 59790,
      "lance_insert": 578,
      "git_coupling": 895,
      "git_commits": 2092,
      "deps": 22,
      "compact": 237,
      "other/overhead": 4366,
      "total_ms": 95532,
      "embed_throughput_chunks_per_sec": 2147.6
    },
    "total_files": null,
    "total_chunks": null,
    "total_embeddings": null,
    "languages": []
  },
  "run_id": "20260210-204253-0134"
}