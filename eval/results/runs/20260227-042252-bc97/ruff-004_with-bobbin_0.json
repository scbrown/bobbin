{
  "task_id": "ruff-004",
  "approach": "with-bobbin",
  "attempt": 0,
  "status": "completed",
  "timestamp": "2026-02-27T04:28:08.925018+00:00",
  "task": {
    "repo": "astral-sh/ruff",
    "commit": "ceb876b82300bd237d11e3eb77c46fcf3d3afe85",
    "test_command": "cargo test -p ruff_linter -- PYI034",
    "language": "rust",
    "difficulty": "easy"
  },
  "agent_config": {
    "model": "claude-opus-4-6",
    "budget_usd": 100.0,
    "timeout_seconds": 3600,
    "index_timeout_seconds": 600
  },
  "agent_result": {
    "exit_code": 0,
    "duration_seconds": 203.37,
    "timed_out": false,
    "cost_usd": 1.5393777499999997,
    "input_tokens": 2048025,
    "output_tokens": 7883,
    "model_usage": {
      "claude-opus-4-6": {
        "inputTokens": 73,
        "outputTokens": 7883,
        "cacheReadInputTokens": 1994667,
        "cacheCreationInputTokens": 53285,
        "webSearchRequests": 0,
        "costUSD": 1.5278047499999996,
        "contextWindow": 200000,
        "maxOutputTokens": 32000
      },
      "claude-haiku-4-5-20251001": {
        "inputTokens": 9653,
        "outputTokens": 384,
        "cacheReadInputTokens": 0,
        "cacheCreationInputTokens": 0,
        "webSearchRequests": 0,
        "costUSD": 0.011572999999999998,
        "contextWindow": 200000,
        "maxOutputTokens": 32000
      }
    },
    "num_turns": 42
  },
  "token_usage": {
    "total_cost_usd": 1.5393777499999997,
    "input_tokens": 73,
    "output_tokens": 7883,
    "cache_creation_tokens": 53285,
    "cache_read_tokens": 1994667,
    "num_turns": 42,
    "model_usage": {
      "claude-opus-4-6": {
        "inputTokens": 73,
        "outputTokens": 7883,
        "cacheReadInputTokens": 1994667,
        "cacheCreationInputTokens": 53285,
        "webSearchRequests": 0,
        "costUSD": 1.5278047499999996,
        "contextWindow": 200000,
        "maxOutputTokens": 32000
      },
      "claude-haiku-4-5-20251001": {
        "inputTokens": 9653,
        "outputTokens": 384,
        "cacheReadInputTokens": 0,
        "cacheCreationInputTokens": 0,
        "webSearchRequests": 0,
        "costUSD": 0.011572999999999998,
        "contextWindow": 200000,
        "maxOutputTokens": 32000
      }
    }
  },
  "agent_output": {
    "num_turns": 42,
    "session_id": "691a644e-2111-4e59-a4a8-6690b0d83c4a",
    "stop_reason": null
  },
  "agent_stderr": "",
  "test_result": {
    "passed": true,
    "total": 0,
    "failures": 0,
    "parsed": {
      "framework": "pytest",
      "passed": 0,
      "failed": 0,
      "skipped": 0,
      "total": 0
    },
    "output": "\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 2630 filtered out; finished in 0.00s\n\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 11 filtered out; finished in 0.00s\n\nall doctests ran in 0.59s; merged doctests compilation took 0.58s\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.14s\n     Running unittests src/lib.rs (target/debug/deps/ruff_linter-98eacd2c45aa9f28)\n   Doc-tests ruff_linter\n",
    "exit_code": 0,
    "timed_out": false
  },
  "diff_result": {
    "file_precision": 1.0,
    "file_recall": 1.0,
    "f1": 1.0,
    "files_touched": [
      "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py",
      "crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs",
      "crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap"
    ],
    "ground_truth_files": [
      "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py",
      "crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs",
      "crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap"
    ],
    "exact_file_match": true
  },
  "agent_diff": "diff --git a/.claude/CLAUDE.md b/.claude/CLAUDE.md\nindex 96b2559f48..1160553fdb 100644\n--- a/.claude/CLAUDE.md\n+++ b/.claude/CLAUDE.md\n@@ -17,9 +17,9 @@ bobbin grep \"pattern\"                     # regex search across all files\n ## Workflow\n \n 1. **Start with `bobbin search`** to find relevant code for your task\n-2. **Use `bobbin related`** on key files to discover test files and dependencies\n-3. **Use `bobbin refs`** to trace symbol usage across the codebase\n-4. Read the files bobbin identifies, then make targeted changes\n+1. **Use `bobbin related`** on key files to discover test files and dependencies\n+1. **Use `bobbin refs`** to trace symbol usage across the codebase\n+1. Read the files bobbin identifies, then make targeted changes\n \n Bobbin context is also injected automatically when you submit prompts and after\n file edits \u2014 check the system messages for relevant code snippets.\ndiff --git a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\nindex b35efc3c21..d86d0c5d8b 100644\n--- a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n+++ b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n@@ -322,6 +322,16 @@ class UsesStringizedAnnotations:\n     def __iadd__(self, other: \"UsesStringizedAnnotations\") -> \"typing.Self\":\n         return self\n \n+class UsesStringizedAnnotationsForReturnType:\n+    def __new__(cls, *args: Any, **kwargs: Any) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+        ...\n+\n+    def __enter__(self) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+        ...\n+\n+    async def __aenter__(self) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+        ...\n+\n \n class NonGeneric1(tuple):\n     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\nindex d3b2f75b2d..eff8cc9ac6 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n@@ -182,7 +182,7 @@ pub(crate) fn non_self_return_type(\n \n     if is_async {\n         if name == \"__aenter__\"\n-            && is_name(returns, &class_def.name)\n+            && is_name_or_stringized_name(checker, returns, &class_def.name)\n             && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -198,7 +198,7 @@ pub(crate) fn non_self_return_type(\n         return;\n     }\n \n-    if is_name(returns, &class_def.name) {\n+    if is_name_or_stringized_name(checker, returns, &class_def.name) {\n         if matches!(name, \"__enter__\" | \"__new__\") && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -327,6 +327,12 @@ fn is_name(expr: &ast::Expr, name: &str) -> bool {\n     id.as_str() == name\n }\n \n+/// Return `true` if the given expression resolves to the given name,\n+/// handling both plain and stringized (forward reference) annotations.\n+fn is_name_or_stringized_name(checker: &Checker, expr: &ast::Expr, name: &str) -> bool {\n+    checker.match_maybe_stringized_annotation(expr, |inner| is_name(inner, name))\n+}\n+\n /// Return `true` if the given expression resolves to `typing.Self`.\n fn is_self(expr: &ast::Expr, checker: &Checker) -> bool {\n     checker.match_maybe_stringized_annotation(expr, |expr| {\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\nindex 8893a346e1..c6df598784 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n@@ -217,258 +217,317 @@ help: Use `Self` as return type\n 206 | class AsyncIteratorReturningAsyncIterable:\n note: This is an unsafe fix and may change runtime behavior\n \n-PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime\n-   --> PYI034.py:327:9\n+PYI034 [*] `__new__` methods in classes like `UsesStringizedAnnotationsForReturnType` usually return `self` at runtime\n+   --> PYI034.py:326:9\n     |\n-326 | class NonGeneric1(tuple):\n-327 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+325 | class UsesStringizedAnnotationsForReturnType:\n+326 |     def __new__(cls, *args: Any, **kwargs: Any) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n     |         ^^^^^^^\n-328 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+327 |         ...\n     |\n help: Use `Self` as return type\n+323 |         return self\n 324 | \n-325 | \n-326 | class NonGeneric1(tuple):\n+325 | class UsesStringizedAnnotationsForReturnType:\n+    -     def __new__(cls, *args: Any, **kwargs: Any) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+326 +     def __new__(cls, *args: Any, **kwargs: Any) -> typing.Self:  # PYI034\n+327 |         ...\n+328 | \n+329 |     def __enter__(self) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__enter__` methods in classes like `UsesStringizedAnnotationsForReturnType` usually return `self` at runtime\n+   --> PYI034.py:329:9\n+    |\n+327 |         ...\n+328 |\n+329 |     def __enter__(self) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+    |         ^^^^^^^^^\n+330 |         ...\n+    |\n+help: Use `Self` as return type\n+326 |     def __new__(cls, *args: Any, **kwargs: Any) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+327 |         ...\n+328 | \n+    -     def __enter__(self) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+329 +     def __enter__(self) -> typing.Self:  # PYI034\n+330 |         ...\n+331 | \n+332 |     async def __aenter__(self) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__aenter__` methods in classes like `UsesStringizedAnnotationsForReturnType` usually return `self` at runtime\n+   --> PYI034.py:332:15\n+    |\n+330 |         ...\n+331 |\n+332 |     async def __aenter__(self) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+    |               ^^^^^^^^^^\n+333 |         ...\n+    |\n+help: Use `Self` as return type\n+329 |     def __enter__(self) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+330 |         ...\n+331 | \n+    -     async def __aenter__(self) -> \"UsesStringizedAnnotationsForReturnType\":  # PYI034\n+332 +     async def __aenter__(self) -> typing.Self:  # PYI034\n+333 |         ...\n+334 | \n+335 | \n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime\n+   --> PYI034.py:337:9\n+    |\n+336 | class NonGeneric1(tuple):\n+337 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+    |         ^^^^^^^\n+338 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+    |\n+help: Use `Self` as return type\n+334 | \n+335 | \n+336 | class NonGeneric1(tuple):\n     -     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n-327 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...\n-328 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-329 | \n-330 | class NonGeneric2(tuple):\n+337 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...\n+338 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+339 | \n+340 | class NonGeneric2(tuple):\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__enter__` methods in classes like `NonGeneric1` usually return `self` at runtime\n-   --> PYI034.py:328:9\n+   --> PYI034.py:338:9\n     |\n-326 | class NonGeneric1(tuple):\n-327 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n-328 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+336 | class NonGeneric1(tuple):\n+337 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+338 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n     |         ^^^^^^^^^\n-329 |\n-330 | class NonGeneric2(tuple):\n+339 |\n+340 | class NonGeneric2(tuple):\n     |\n help: Use `Self` as return type\n-325 | \n-326 | class NonGeneric1(tuple):\n-327 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+335 | \n+336 | class NonGeneric1(tuple):\n+337 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n     -     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-328 +     def __enter__(self) -> typing.Self: ...\n-329 | \n-330 | class NonGeneric2(tuple):\n-331 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+338 +     def __enter__(self) -> typing.Self: ...\n+339 | \n+340 | class NonGeneric2(tuple):\n+341 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__new__` methods in classes like `NonGeneric2` usually return `self` at runtime\n-   --> PYI034.py:331:9\n+   --> PYI034.py:341:9\n     |\n-330 | class NonGeneric2(tuple):\n-331 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+340 | class NonGeneric2(tuple):\n+341 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n     |         ^^^^^^^\n-332 |\n-333 | class Generic1[T](list):\n+342 |\n+343 | class Generic1[T](list):\n     |\n help: Use `Self` as return type\n-328 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-329 | \n-330 | class NonGeneric2(tuple):\n+338 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+339 | \n+340 | class NonGeneric2(tuple):\n     -     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n-331 +     def __new__(cls) -> typing.Self: ...\n-332 | \n-333 | class Generic1[T](list):\n-334 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+341 +     def __new__(cls) -> typing.Self: ...\n+342 | \n+343 | class Generic1[T](list):\n+344 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__new__` methods in classes like `Generic1` usually return `self` at runtime\n-   --> PYI034.py:334:9\n+   --> PYI034.py:344:9\n     |\n-333 | class Generic1[T](list):\n-334 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+343 | class Generic1[T](list):\n+344 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n     |         ^^^^^^^\n-335 |     def __enter__(self: Generic1) -> Generic1: ...\n+345 |     def __enter__(self: Generic1) -> Generic1: ...\n     |\n help: Use `Self` as return type\n-331 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n-332 | \n-333 | class Generic1[T](list):\n+341 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+342 | \n+343 | class Generic1[T](list):\n     -     def __new__(cls: type[Generic1]) -> Generic1: ...\n-334 +     def __new__(cls) -> typing.Self: ...\n-335 |     def __enter__(self: Generic1) -> Generic1: ...\n-336 | \n-337 | \n+344 +     def __new__(cls) -> typing.Self: ...\n+345 |     def __enter__(self: Generic1) -> Generic1: ...\n+346 | \n+347 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic1` usually return `self` at runtime\n-   --> PYI034.py:335:9\n+   --> PYI034.py:345:9\n     |\n-333 | class Generic1[T](list):\n-334 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n-335 |     def __enter__(self: Generic1) -> Generic1: ...\n+343 | class Generic1[T](list):\n+344 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+345 |     def __enter__(self: Generic1) -> Generic1: ...\n     |         ^^^^^^^^^\n     |\n help: Use `Self` as return type\n-332 | \n-333 | class Generic1[T](list):\n-334 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+342 | \n+343 | class Generic1[T](list):\n+344 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n     -     def __enter__(self: Generic1) -> Generic1: ...\n-335 +     def __enter__(self) -> typing.Self: ...\n-336 | \n-337 | \n-338 | ### Correctness of typevar-likes are not verified.\n+345 +     def __enter__(self) -> typing.Self: ...\n+346 | \n+347 | \n+348 | ### Correctness of typevar-likes are not verified.\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic2` usually return `self` at runtime\n-   --> PYI034.py:345:9\n+   --> PYI034.py:355:9\n     |\n-344 | class Generic2(Generic[T]):\n-345 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+354 | class Generic2(Generic[T]):\n+355 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n     |         ^^^^^^^\n-346 |     def __enter__(self: Generic2) -> Generic2: ...\n+356 |     def __enter__(self: Generic2) -> Generic2: ...\n     |\n help: Use `Self` as return type\n-342 | Ts = TypeVarTuple('foo')\n-343 | \n-344 | class Generic2(Generic[T]):\n+352 | Ts = TypeVarTuple('foo')\n+353 | \n+354 | class Generic2(Generic[T]):\n     -     def __new__(cls: type[Generic2]) -> Generic2: ...\n-345 +     def __new__(cls) -> typing.Self: ...\n-346 |     def __enter__(self: Generic2) -> Generic2: ...\n-347 | \n-348 | class Generic3(tuple[*Ts]):\n+355 +     def __new__(cls) -> typing.Self: ...\n+356 |     def __enter__(self: Generic2) -> Generic2: ...\n+357 | \n+358 | class Generic3(tuple[*Ts]):\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic2` usually return `self` at runtime\n-   --> PYI034.py:346:9\n+   --> PYI034.py:356:9\n     |\n-344 | class Generic2(Generic[T]):\n-345 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n-346 |     def __enter__(self: Generic2) -> Generic2: ...\n+354 | class Generic2(Generic[T]):\n+355 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+356 |     def __enter__(self: Generic2) -> Generic2: ...\n     |         ^^^^^^^^^\n-347 |\n-348 | class Generic3(tuple[*Ts]):\n+357 |\n+358 | class Generic3(tuple[*Ts]):\n     |\n help: Use `Self` as return type\n-343 | \n-344 | class Generic2(Generic[T]):\n-345 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+353 | \n+354 | class Generic2(Generic[T]):\n+355 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n     -     def __enter__(self: Generic2) -> Generic2: ...\n-346 +     def __enter__(self) -> typing.Self: ...\n-347 | \n-348 | class Generic3(tuple[*Ts]):\n-349 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+356 +     def __enter__(self) -> typing.Self: ...\n+357 | \n+358 | class Generic3(tuple[*Ts]):\n+359 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic3` usually return `self` at runtime\n-   --> PYI034.py:349:9\n+   --> PYI034.py:359:9\n     |\n-348 | class Generic3(tuple[*Ts]):\n-349 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+358 | class Generic3(tuple[*Ts]):\n+359 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n     |         ^^^^^^^\n-350 |     def __enter__(self: Generic3) -> Generic3: ...\n+360 |     def __enter__(self: Generic3) -> Generic3: ...\n     |\n help: Use `Self` as return type\n-346 |     def __enter__(self: Generic2) -> Generic2: ...\n-347 | \n-348 | class Generic3(tuple[*Ts]):\n+356 |     def __enter__(self: Generic2) -> Generic2: ...\n+357 | \n+358 | class Generic3(tuple[*Ts]):\n     -     def __new__(cls: type[Generic3]) -> Generic3: ...\n-349 +     def __new__(cls) -> typing.Self: ...\n-350 |     def __enter__(self: Generic3) -> Generic3: ...\n-351 | \n-352 | class Generic4(collections.abc.Callable[P, ...]):\n+359 +     def __new__(cls) -> typing.Self: ...\n+360 |     def __enter__(self: Generic3) -> Generic3: ...\n+361 | \n+362 | class Generic4(collections.abc.Callable[P, ...]):\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic3` usually return `self` at runtime\n-   --> PYI034.py:350:9\n+   --> PYI034.py:360:9\n     |\n-348 | class Generic3(tuple[*Ts]):\n-349 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n-350 |     def __enter__(self: Generic3) -> Generic3: ...\n+358 | class Generic3(tuple[*Ts]):\n+359 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+360 |     def __enter__(self: Generic3) -> Generic3: ...\n     |         ^^^^^^^^^\n-351 |\n-352 | class Generic4(collections.abc.Callable[P, ...]):\n+361 |\n+362 | class Generic4(collections.abc.Callable[P, ...]):\n     |\n help: Use `Self` as return type\n-347 | \n-348 | class Generic3(tuple[*Ts]):\n-349 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+357 | \n+358 | class Generic3(tuple[*Ts]):\n+359 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n     -     def __enter__(self: Generic3) -> Generic3: ...\n-350 +     def __enter__(self) -> typing.Self: ...\n-351 | \n-352 | class Generic4(collections.abc.Callable[P, ...]):\n-353 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+360 +     def __enter__(self) -> typing.Self: ...\n+361 | \n+362 | class Generic4(collections.abc.Callable[P, ...]):\n+363 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic4` usually return `self` at runtime\n-   --> PYI034.py:353:9\n+   --> PYI034.py:363:9\n     |\n-352 | class Generic4(collections.abc.Callable[P, ...]):\n-353 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+362 | class Generic4(collections.abc.Callable[P, ...]):\n+363 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n     |         ^^^^^^^\n-354 |     def __enter__(self: Generic4) -> Generic4: ...\n+364 |     def __enter__(self: Generic4) -> Generic4: ...\n     |\n help: Use `Self` as return type\n-350 |     def __enter__(self: Generic3) -> Generic3: ...\n-351 | \n-352 | class Generic4(collections.abc.Callable[P, ...]):\n+360 |     def __enter__(self: Generic3) -> Generic3: ...\n+361 | \n+362 | class Generic4(collections.abc.Callable[P, ...]):\n     -     def __new__(cls: type[Generic4]) -> Generic4: ...\n-353 +     def __new__(cls) -> typing.Self: ...\n-354 |     def __enter__(self: Generic4) -> Generic4: ...\n-355 | \n-356 | from some_module import PotentialTypeVar\n+363 +     def __new__(cls) -> typing.Self: ...\n+364 |     def __enter__(self: Generic4) -> Generic4: ...\n+365 | \n+366 | from some_module import PotentialTypeVar\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic4` usually return `self` at runtime\n-   --> PYI034.py:354:9\n+   --> PYI034.py:364:9\n     |\n-352 | class Generic4(collections.abc.Callable[P, ...]):\n-353 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n-354 |     def __enter__(self: Generic4) -> Generic4: ...\n+362 | class Generic4(collections.abc.Callable[P, ...]):\n+363 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+364 |     def __enter__(self: Generic4) -> Generic4: ...\n     |         ^^^^^^^^^\n-355 |\n-356 | from some_module import PotentialTypeVar\n+365 |\n+366 | from some_module import PotentialTypeVar\n     |\n help: Use `Self` as return type\n-351 | \n-352 | class Generic4(collections.abc.Callable[P, ...]):\n-353 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+361 | \n+362 | class Generic4(collections.abc.Callable[P, ...]):\n+363 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n     -     def __enter__(self: Generic4) -> Generic4: ...\n-354 +     def __enter__(self) -> typing.Self: ...\n-355 | \n-356 | from some_module import PotentialTypeVar\n-357 | \n+364 +     def __enter__(self) -> typing.Self: ...\n+365 | \n+366 | from some_module import PotentialTypeVar\n+367 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic5` usually return `self` at runtime\n-   --> PYI034.py:359:9\n+   --> PYI034.py:369:9\n     |\n-358 | class Generic5(list[PotentialTypeVar]):\n-359 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+368 | class Generic5(list[PotentialTypeVar]):\n+369 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n     |         ^^^^^^^\n-360 |     def __enter__(self: Generic5) -> Generic5: ...\n+370 |     def __enter__(self: Generic5) -> Generic5: ...\n     |\n help: Use `Self` as return type\n-356 | from some_module import PotentialTypeVar\n-357 | \n-358 | class Generic5(list[PotentialTypeVar]):\n+366 | from some_module import PotentialTypeVar\n+367 | \n+368 | class Generic5(list[PotentialTypeVar]):\n     -     def __new__(cls: type[Generic5]) -> Generic5: ...\n-359 +     def __new__(cls) -> typing.Self: ...\n-360 |     def __enter__(self: Generic5) -> Generic5: ...\n-361 | \n-362 | \n+369 +     def __new__(cls) -> typing.Self: ...\n+370 |     def __enter__(self: Generic5) -> Generic5: ...\n+371 | \n+372 | \n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__enter__` methods in classes like `Generic5` usually return `self` at runtime\n-   --> PYI034.py:360:9\n+   --> PYI034.py:370:9\n     |\n-358 | class Generic5(list[PotentialTypeVar]):\n-359 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n-360 |     def __enter__(self: Generic5) -> Generic5: ...\n+368 | class Generic5(list[PotentialTypeVar]):\n+369 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+370 |     def __enter__(self: Generic5) -> Generic5: ...\n     |         ^^^^^^^^^\n     |\n help: Use `Self` as return type\n-357 | \n-358 | class Generic5(list[PotentialTypeVar]):\n-359 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+367 | \n+368 | class Generic5(list[PotentialTypeVar]):\n+369 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n     -     def __enter__(self: Generic5) -> Generic5: ...\n-360 +     def __enter__(self) -> typing.Self: ...\n-361 | \n-362 | \n-363 | # Test cases based on issue #20781 - metaclasses that triggers IsMetaclass::Maybe\n+370 +     def __enter__(self) -> typing.Self: ...\n+371 | \n+372 | \n+373 | # Test cases based on issue #20781 - metaclasses that triggers IsMetaclass::Maybe\n note: This is an unsafe fix and may change runtime behavior\n",
  "ground_truth_diff": "diff --git a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\nindex b35efc3c21..37ad3d3706 100644\n--- a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n+++ b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n@@ -385,3 +385,10 @@ class MetaclassInWhichSelfCannotBeUsed7(django.db.models.base.ModelBase):\n class MetaclassInWhichSelfCannotBeUsed8(django.db.models.base.ModelBase):\n     def __new__(cls, name: builtins.str, bases: tuple, attributes: dict, /, **kw) -> MetaclassInWhichSelfCannotBeUsed8:\n         ...\n+\n+\n+class UsesStringizedForwardReferences:\n+    def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\nindex d3b2f75b2d..e74363a446 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n@@ -182,7 +182,7 @@ pub(crate) fn non_self_return_type(\n \n     if is_async {\n         if name == \"__aenter__\"\n-            && is_name(returns, &class_def.name)\n+            && is_name_or_stringized_name(returns, &class_def.name, checker)\n             && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -198,7 +198,7 @@ pub(crate) fn non_self_return_type(\n         return;\n     }\n \n-    if is_name(returns, &class_def.name) {\n+    if is_name_or_stringized_name(returns, &class_def.name, checker) {\n         if matches!(name, \"__enter__\" | \"__new__\") && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -327,6 +327,11 @@ fn is_name(expr: &ast::Expr, name: &str) -> bool {\n     id.as_str() == name\n }\n \n+/// Return `true` if the given expression resolves to the given name,\n+fn is_name_or_stringized_name(expr: &ast::Expr, name: &str, checker: &Checker) -> bool {\n+    checker.match_maybe_stringized_annotation(expr, |expr| is_name(expr, name))\n+}\n+\n /// Return `true` if the given expression resolves to `typing.Self`.\n fn is_self(expr: &ast::Expr, checker: &Checker) -> bool {\n     checker.match_maybe_stringized_annotation(expr, |expr| {\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\nindex 8893a346e1..c730e8a2b6 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n@@ -472,3 +472,77 @@ help: Use `Self` as return type\n 362 | \n 363 | # Test cases based on issue #20781 - metaclasses that triggers IsMetaclass::Maybe\n note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__new__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:391:9\n+    |\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    |         ^^^^^^^\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+388 | \n+389 | \n+390 | class UsesStringizedForwardReferences:\n+    -     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+391 +     def __new__(cls) -> typing.Self: ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__enter__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:392:9\n+    |\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    |         ^^^^^^^^^\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+389 | \n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    -     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+392 +     def __enter__(self) -> typing.Self: ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__aenter__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:393:15\n+    |\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |               ^^^^^^^^^^\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    -     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+393 +     async def __aenter__(self) -> typing.Self: ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__iadd__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:394:9\n+    |\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |         ^^^^^^^^\n+    |\n+help: Use `Self` as return type\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    -     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 +     def __iadd__(self, other) -> typing.Self: ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n",
  "project_metadata": {
    "CSS": {
      "files": 3,
      "lines": 377,
      "code": 322,
      "comments": 6,
      "blanks": 49
    },
    "Dockerfile": {
      "files": 1,
      "lines": 38,
      "code": 26,
      "comments": 7,
      "blanks": 5
    },
    "HTML": {
      "files": 2,
      "lines": 81,
      "code": 81,
      "comments": 0,
      "blanks": 0
    },
    "JavaScript": {
      "files": 2,
      "lines": 97,
      "code": 77,
      "comments": 11,
      "blanks": 9
    },
    "JSON": {
      "files": 134,
      "lines": 15716,
      "code": 15706,
      "comments": 0,
      "blanks": 10
    },
    "Jupyter Notebooks": {
      "files": 35,
      "lines": 511,
      "code": 289,
      "comments": 154,
      "blanks": 68
    },
    "Markdown": {
      "files": 391,
      "lines": 117506,
      "code": 0,
      "comments": 85634,
      "blanks": 31872
    },
    "Python": {
      "files": 3687,
      "lines": 266549,
      "code": 211732,
      "comments": 12788,
      "blanks": 42029
    },
    "Rust": {
      "files": 1743,
      "lines": 511275,
      "code": 432571,
      "comments": 25123,
      "blanks": 53581
    },
    "Shell": {
      "files": 15,
      "lines": 489,
      "code": 274,
      "comments": 143,
      "blanks": 72
    },
    "SVG": {
      "files": 28,
      "lines": 1445,
      "code": 1308,
      "comments": 71,
      "blanks": 66
    },
    "Plain Text": {
      "files": 43,
      "lines": 188649,
      "code": 0,
      "comments": 188648,
      "blanks": 1
    },
    "TOML": {
      "files": 144,
      "lines": 4323,
      "code": 3625,
      "comments": 219,
      "blanks": 479
    },
    "TSX": {
      "files": 30,
      "lines": 5526,
      "code": 4810,
      "comments": 163,
      "blanks": 553
    },
    "TypeScript": {
      "files": 14,
      "lines": 480,
      "code": 363,
      "comments": 61,
      "blanks": 56
    },
    "YAML": {
      "files": 24,
      "lines": 3705,
      "code": 3093,
      "comments": 288,
      "blanks": 324
    },
    "Total": {
      "files": 0,
      "lines": 1195029,
      "code": 687056,
      "comments": 364538,
      "blanks": 143435
    }
  },
  "bobbin_metadata": {
    "index_duration_seconds": 49.96,
    "profile": {
      "file_i/o": 0,
      "parse": 1023,
      "context": 1,
      "embed": 15318,
      "tokenize": 2861,
      "inference": 11316,
      "pooling": 408,
      "lance_delete": 0,
      "lance_insert": 506,
      "git_coupling": 430,
      "git_commits": 20557,
      "deps": 19,
      "compact": 230,
      "other/overhead": 9300,
      "total_ms": 47384,
      "embed_throughput_chunks_per_sec": 3679.2
    },
    "total_files": null,
    "total_chunks": null,
    "total_embeddings": null,
    "languages": []
  },
  "bobbin_metrics": {
    "injection_count": 1,
    "gate_skip_count": 0,
    "gate_skip_details": [],
    "dedup_skip_count": 0,
    "prime_context_fired": true,
    "command_invocations": [
      {
        "command": "search",
        "duration_ms": 1784
      },
      {
        "command": "search",
        "duration_ms": 1735
      }
    ],
    "injected_files": [
      "CHANGELOG.md",
      "changelogs/0.1.x.md",
      "changelogs/0.12.x.md",
      "changelogs/0.3.x.md",
      "changelogs/0.4.x.md",
      "changelogs/0.5.x.md",
      "changelogs/0.6.x.md",
      "changelogs/0.8.x.md",
      "changelogs/0.9.x.md"
    ],
    "total_events": 7,
    "overlap": {
      "injection_precision": 0.0,
      "injection_recall": 0.0,
      "overlap_files": []
    }
  },
  "injection_result": {
    "injection_precision": 0.0,
    "injection_recall": 0.0,
    "injection_f1": 0.0,
    "injected_and_touched": [],
    "injected_not_touched": [
      "CHANGELOG.md",
      "changelogs/0.1.x.md",
      "changelogs/0.12.x.md",
      "changelogs/0.3.x.md",
      "changelogs/0.4.x.md",
      "changelogs/0.5.x.md",
      "changelogs/0.6.x.md",
      "changelogs/0.8.x.md",
      "changelogs/0.9.x.md"
    ],
    "touched_not_injected": [
      "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py",
      "crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs",
      "crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap"
    ]
  },
  "config_overrides": null,
  "tool_use_summary": {
    "by_tool": {
      "TodoWrite": 7,
      "Bash": 14,
      "Grep": 8,
      "Glob": 2,
      "Read": 6,
      "Edit": 4
    },
    "tool_sequence": [
      "TodoWrite",
      "Bash",
      "Bash",
      "Bash",
      "Grep",
      "Glob",
      "Read",
      "Read",
      "Read",
      "TodoWrite",
      "Grep",
      "TodoWrite",
      "Edit",
      "TodoWrite",
      "Edit",
      "Edit",
      "TodoWrite",
      "Read",
      "Edit",
      "Glob",
      "Read",
      "TodoWrite",
      "Bash",
      "Grep",
      "Bash",
      "Grep",
      "Grep",
      "Grep",
      "Read",
      "Grep",
      "Grep",
      "Bash",
      "Bash",
      "Bash",
      "Bash",
      "Bash",
      "Bash",
      "Bash",
      "Bash",
      "Bash",
      "TodoWrite"
    ],
    "first_edit_turn": 17,
    "bobbin_commands": [
      "bobbin search \"PYI034 non_self_return_type forward reference stringized annotation\"",
      "bobbin refs match_maybe_stringized_annotation",
      "bobbin search \"non_self_return_type PYI034 rule implementation\""
    ]
  },
  "output_summary": "All tests pass and pre-commit checks are clean. Here's a summary of the changes:\n\n## Summary\n\n**Problem:** The PYI034 rule (`NonSelfReturnType`) didn't detect forward references (stringized annotations) like `def __new__(cls) -> \"MyClass\"` for `__new__`, `__enter__`, and `__aenter__` methods. Only plain annotations like `-> MyClass` were caught.\n\n**Root cause:** The `is_name()` function only matches `Expr::Name` nodes, but stringized annotations produce `Expr::StringLiteral` nodes.\n\n**Fix (3 files changed):**\n\n1. **`crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs`:**\n   - Added `is_name_or_stringized_name()` helper that wraps `is_name()` with `checker.match_maybe_stringized_annotation()` to resolve both plain and stringized annotations\n   - Updated the `__aenter__` check (line 185) and the `__enter__`/`__new__` check (line 201) to use the new helper instead of bare `is_name()`\n\n2. **`crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py`:** Added `UsesStringizedAnnotationsForReturnType` test class with stringized return types for `__new__`, `__enter__`, and `__aenter__`\n\n3. **Snapshot updated** to include the 3 new diagnostics",
  "run_id": "20260227-042252-bc97"
}