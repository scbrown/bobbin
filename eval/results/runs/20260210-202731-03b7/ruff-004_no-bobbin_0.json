{
  "task_id": "ruff-004",
  "approach": "no-bobbin",
  "attempt": 0,
  "status": "completed",
  "timestamp": "2026-02-10T20:31:47.196114+00:00",
  "task": {
    "repo": "astral-sh/ruff",
    "commit": "ceb876b82300bd237d11e3eb77c46fcf3d3afe85",
    "test_command": "cargo test -p ruff_linter -- PYI034",
    "language": "rust",
    "difficulty": "easy"
  },
  "agent_result": {
    "exit_code": 0,
    "duration_seconds": 243.72,
    "timed_out": false
  },
  "test_result": {
    "passed": true,
    "total": 0,
    "failures": 0,
    "parsed": {
      "framework": "pytest",
      "passed": 0,
      "failed": 0,
      "skipped": 0,
      "total": 0
    }
  },
  "diff_result": {
    "file_precision": 0.3333,
    "file_recall": 0.3333,
    "f1": 0.3333,
    "files_touched": [
      "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi",
      "crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs",
      "crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap"
    ],
    "ground_truth_files": [
      "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py",
      "crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs",
      "crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap"
    ],
    "exact_file_match": false
  },
  "agent_diff": "diff --git a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi\nindex b22f76798b..582dd2d252 100644\n--- a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi\n+++ b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi\n@@ -217,6 +217,19 @@ class UsesStringizedAnnotations:\n     def __iadd__(self, other: \"UsesStringizedAnnotations\") -> \"typing.Self\": ...\n \n \n+class StringizedReturnTypes:\n+    def __new__(cls) -> \"StringizedReturnTypes\": ...  # Y034\n+    def __enter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+    async def __aenter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+\n+\n+@final\n+class StringizedReturnTypesFinal:\n+    def __new__(cls) -> \"StringizedReturnTypesFinal\": ...\n+    def __enter__(self) -> \"StringizedReturnTypesFinal\": ...\n+    async def __aenter__(self) -> \"StringizedReturnTypesFinal\": ...\n+\n+\n class NonGeneric1(tuple):\n     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\nindex d3b2f75b2d..a16e2e2e6b 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n@@ -182,7 +182,7 @@ pub(crate) fn non_self_return_type(\n \n     if is_async {\n         if name == \"__aenter__\"\n-            && is_name(returns, &class_def.name)\n+            && is_name_or_stringized_name(returns, &class_def.name, checker)\n             && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -198,7 +198,7 @@ pub(crate) fn non_self_return_type(\n         return;\n     }\n \n-    if is_name(returns, &class_def.name) {\n+    if is_name_or_stringized_name(returns, &class_def.name, checker) {\n         if matches!(name, \"__enter__\" | \"__new__\") && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -327,6 +327,11 @@ fn is_name(expr: &ast::Expr, name: &str) -> bool {\n     id.as_str() == name\n }\n \n+/// Return `true` if the given expression resolves to the given name, including stringized annotations.\n+fn is_name_or_stringized_name(expr: &ast::Expr, name: &str, checker: &Checker) -> bool {\n+    checker.match_maybe_stringized_annotation(expr, |expr| is_name(expr, name))\n+}\n+\n /// Return `true` if the given expression resolves to `typing.Self`.\n fn is_self(expr: &ast::Expr, checker: &Checker) -> bool {\n     checker.match_maybe_stringized_annotation(expr, |expr| {\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap\nindex 29c91b9a77..f7df9b3fe4 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap\n@@ -1,5 +1,6 @@\n ---\n source: crates/ruff_linter/src/rules/flake8_pyi/mod.rs\n+assertion_line: 137\n ---\n PYI034 [*] `__new__` methods in classes like `Bad` usually return `self` at runtime\n   --> PYI034.pyi:20:9\n@@ -198,258 +199,317 @@ help: Use `Self` as return type\n 149 |     def __aiter__(\n note: This is an unsafe fix and may change runtime behavior\n \n-PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime\n+PYI034 [*] `__new__` methods in classes like `StringizedReturnTypes` usually return `self` at runtime\n    --> PYI034.pyi:221:9\n     |\n-220 | class NonGeneric1(tuple):\n-221 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+220 | class StringizedReturnTypes:\n+221 |     def __new__(cls) -> \"StringizedReturnTypes\": ...  # Y034\n     |         ^^^^^^^\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+222 |     def __enter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+223 |     async def __aenter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n     |\n help: Use `Self` as return type\n 218 | \n 219 | \n-220 | class NonGeneric1(tuple):\n-    -     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n-221 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-223 | \n-224 | class NonGeneric2(tuple):\n+220 | class StringizedReturnTypes:\n+    -     def __new__(cls) -> \"StringizedReturnTypes\": ...  # Y034\n+221 +     def __new__(cls) -> typing.Self: ...  # Y034\n+222 |     def __enter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+223 |     async def __aenter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+224 | \n note: This is an unsafe fix and may change runtime behavior\n \n-PYI034 [*] `__enter__` methods in classes like `NonGeneric1` usually return `self` at runtime\n+PYI034 [*] `__enter__` methods in classes like `StringizedReturnTypes` usually return `self` at runtime\n    --> PYI034.pyi:222:9\n     |\n-220 | class NonGeneric1(tuple):\n-221 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+220 | class StringizedReturnTypes:\n+221 |     def __new__(cls) -> \"StringizedReturnTypes\": ...  # Y034\n+222 |     def __enter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n     |         ^^^^^^^^^\n-223 |\n-224 | class NonGeneric2(tuple):\n+223 |     async def __aenter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n     |\n help: Use `Self` as return type\n 219 | \n-220 | class NonGeneric1(tuple):\n-221 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+220 | class StringizedReturnTypes:\n+221 |     def __new__(cls) -> \"StringizedReturnTypes\": ...  # Y034\n+    -     def __enter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+222 +     def __enter__(self) -> typing.Self: ...  # Y034\n+223 |     async def __aenter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+224 | \n+225 | \n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__aenter__` methods in classes like `StringizedReturnTypes` usually return `self` at runtime\n+   --> PYI034.pyi:223:15\n+    |\n+221 |     def __new__(cls) -> \"StringizedReturnTypes\": ...  # Y034\n+222 |     def __enter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+223 |     async def __aenter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+    |               ^^^^^^^^^^\n+    |\n+help: Use `Self` as return type\n+220 | class StringizedReturnTypes:\n+221 |     def __new__(cls) -> \"StringizedReturnTypes\": ...  # Y034\n+222 |     def __enter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+    -     async def __aenter__(self) -> \"StringizedReturnTypes\": ...  # Y034\n+223 +     async def __aenter__(self) -> typing.Self: ...  # Y034\n+224 | \n+225 | \n+226 | @final\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime\n+   --> PYI034.pyi:234:9\n+    |\n+233 | class NonGeneric1(tuple):\n+234 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+    |         ^^^^^^^\n+235 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+    |\n+help: Use `Self` as return type\n+231 | \n+232 | \n+233 | class NonGeneric1(tuple):\n+    -     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+234 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...\n+235 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+236 | \n+237 | class NonGeneric2(tuple):\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__enter__` methods in classes like `NonGeneric1` usually return `self` at runtime\n+   --> PYI034.pyi:235:9\n+    |\n+233 | class NonGeneric1(tuple):\n+234 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+235 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+    |         ^^^^^^^^^\n+236 |\n+237 | class NonGeneric2(tuple):\n+    |\n+help: Use `Self` as return type\n+232 | \n+233 | class NonGeneric1(tuple):\n+234 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n     -     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-222 +     def __enter__(self) -> typing.Self: ...\n-223 | \n-224 | class NonGeneric2(tuple):\n-225 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+235 +     def __enter__(self) -> typing.Self: ...\n+236 | \n+237 | class NonGeneric2(tuple):\n+238 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__new__` methods in classes like `NonGeneric2` usually return `self` at runtime\n-   --> PYI034.pyi:225:9\n+   --> PYI034.pyi:238:9\n     |\n-224 | class NonGeneric2(tuple):\n-225 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+237 | class NonGeneric2(tuple):\n+238 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n     |         ^^^^^^^\n-226 |\n-227 | class Generic1[T](list):\n+239 |\n+240 | class Generic1[T](list):\n     |\n help: Use `Self` as return type\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-223 | \n-224 | class NonGeneric2(tuple):\n+235 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+236 | \n+237 | class NonGeneric2(tuple):\n     -     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n-225 +     def __new__(cls) -> typing.Self: ...\n-226 | \n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+238 +     def __new__(cls) -> typing.Self: ...\n+239 | \n+240 | class Generic1[T](list):\n+241 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__new__` methods in classes like `Generic1` usually return `self` at runtime\n-   --> PYI034.pyi:228:9\n+   --> PYI034.pyi:241:9\n     |\n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+240 | class Generic1[T](list):\n+241 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n     |         ^^^^^^^\n-229 |     def __enter__(self: Generic1) -> Generic1: ...\n+242 |     def __enter__(self: Generic1) -> Generic1: ...\n     |\n help: Use `Self` as return type\n-225 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n-226 | \n-227 | class Generic1[T](list):\n+238 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+239 | \n+240 | class Generic1[T](list):\n     -     def __new__(cls: type[Generic1]) -> Generic1: ...\n-228 +     def __new__(cls) -> typing.Self: ...\n-229 |     def __enter__(self: Generic1) -> Generic1: ...\n-230 | \n-231 | \n+241 +     def __new__(cls) -> typing.Self: ...\n+242 |     def __enter__(self: Generic1) -> Generic1: ...\n+243 | \n+244 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic1` usually return `self` at runtime\n-   --> PYI034.pyi:229:9\n+   --> PYI034.pyi:242:9\n     |\n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n-229 |     def __enter__(self: Generic1) -> Generic1: ...\n+240 | class Generic1[T](list):\n+241 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+242 |     def __enter__(self: Generic1) -> Generic1: ...\n     |         ^^^^^^^^^\n     |\n help: Use `Self` as return type\n-226 | \n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+239 | \n+240 | class Generic1[T](list):\n+241 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n     -     def __enter__(self: Generic1) -> Generic1: ...\n-229 +     def __enter__(self) -> typing.Self: ...\n-230 | \n-231 | \n-232 | ### Correctness of typevar-likes are not verified.\n+242 +     def __enter__(self) -> typing.Self: ...\n+243 | \n+244 | \n+245 | ### Correctness of typevar-likes are not verified.\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic2` usually return `self` at runtime\n-   --> PYI034.pyi:239:9\n+   --> PYI034.pyi:252:9\n     |\n-238 | class Generic2(Generic[T]):\n-239 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+251 | class Generic2(Generic[T]):\n+252 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n     |         ^^^^^^^\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n+253 |     def __enter__(self: Generic2) -> Generic2: ...\n     |\n help: Use `Self` as return type\n-236 | Ts = TypeVarTuple('foo')\n-237 | \n-238 | class Generic2(Generic[T]):\n+249 | Ts = TypeVarTuple('foo')\n+250 | \n+251 | class Generic2(Generic[T]):\n     -     def __new__(cls: type[Generic2]) -> Generic2: ...\n-239 +     def __new__(cls) -> typing.Self: ...\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n+252 +     def __new__(cls) -> typing.Self: ...\n+253 |     def __enter__(self: Generic2) -> Generic2: ...\n+254 | \n+255 | class Generic3(tuple[*Ts]):\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic2` usually return `self` at runtime\n-   --> PYI034.pyi:240:9\n+   --> PYI034.pyi:253:9\n     |\n-238 | class Generic2(Generic[T]):\n-239 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n+251 | class Generic2(Generic[T]):\n+252 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+253 |     def __enter__(self: Generic2) -> Generic2: ...\n     |         ^^^^^^^^^\n-241 |\n-242 | class Generic3(tuple[*Ts]):\n+254 |\n+255 | class Generic3(tuple[*Ts]):\n     |\n help: Use `Self` as return type\n-237 | \n-238 | class Generic2(Generic[T]):\n-239 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+250 | \n+251 | class Generic2(Generic[T]):\n+252 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n     -     def __enter__(self: Generic2) -> Generic2: ...\n-240 +     def __enter__(self) -> typing.Self: ...\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+253 +     def __enter__(self) -> typing.Self: ...\n+254 | \n+255 | class Generic3(tuple[*Ts]):\n+256 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic3` usually return `self` at runtime\n-   --> PYI034.pyi:243:9\n+   --> PYI034.pyi:256:9\n     |\n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+255 | class Generic3(tuple[*Ts]):\n+256 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n     |         ^^^^^^^\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n+257 |     def __enter__(self: Generic3) -> Generic3: ...\n     |\n help: Use `Self` as return type\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n+253 |     def __enter__(self: Generic2) -> Generic2: ...\n+254 | \n+255 | class Generic3(tuple[*Ts]):\n     -     def __new__(cls: type[Generic3]) -> Generic3: ...\n-243 +     def __new__(cls) -> typing.Self: ...\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n+256 +     def __new__(cls) -> typing.Self: ...\n+257 |     def __enter__(self: Generic3) -> Generic3: ...\n+258 | \n+259 | class Generic4(collections.abc.Callable[P, ...]):\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic3` usually return `self` at runtime\n-   --> PYI034.pyi:244:9\n+   --> PYI034.pyi:257:9\n     |\n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n+255 | class Generic3(tuple[*Ts]):\n+256 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+257 |     def __enter__(self: Generic3) -> Generic3: ...\n     |         ^^^^^^^^^\n-245 |\n-246 | class Generic4(collections.abc.Callable[P, ...]):\n+258 |\n+259 | class Generic4(collections.abc.Callable[P, ...]):\n     |\n help: Use `Self` as return type\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+254 | \n+255 | class Generic3(tuple[*Ts]):\n+256 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n     -     def __enter__(self: Generic3) -> Generic3: ...\n-244 +     def __enter__(self) -> typing.Self: ...\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+257 +     def __enter__(self) -> typing.Self: ...\n+258 | \n+259 | class Generic4(collections.abc.Callable[P, ...]):\n+260 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic4` usually return `self` at runtime\n-   --> PYI034.pyi:247:9\n+   --> PYI034.pyi:260:9\n     |\n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+259 | class Generic4(collections.abc.Callable[P, ...]):\n+260 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n     |         ^^^^^^^\n-248 |     def __enter__(self: Generic4) -> Generic4: ...\n+261 |     def __enter__(self: Generic4) -> Generic4: ...\n     |\n help: Use `Self` as return type\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n+257 |     def __enter__(self: Generic3) -> Generic3: ...\n+258 | \n+259 | class Generic4(collections.abc.Callable[P, ...]):\n     -     def __new__(cls: type[Generic4]) -> Generic4: ...\n-247 +     def __new__(cls) -> typing.Self: ...\n-248 |     def __enter__(self: Generic4) -> Generic4: ...\n-249 | \n-250 | from some_module import PotentialTypeVar\n+260 +     def __new__(cls) -> typing.Self: ...\n+261 |     def __enter__(self: Generic4) -> Generic4: ...\n+262 | \n+263 | from some_module import PotentialTypeVar\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic4` usually return `self` at runtime\n-   --> PYI034.pyi:248:9\n+   --> PYI034.pyi:261:9\n     |\n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n-248 |     def __enter__(self: Generic4) -> Generic4: ...\n+259 | class Generic4(collections.abc.Callable[P, ...]):\n+260 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+261 |     def __enter__(self: Generic4) -> Generic4: ...\n     |         ^^^^^^^^^\n-249 |\n-250 | from some_module import PotentialTypeVar\n+262 |\n+263 | from some_module import PotentialTypeVar\n     |\n help: Use `Self` as return type\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+258 | \n+259 | class Generic4(collections.abc.Callable[P, ...]):\n+260 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n     -     def __enter__(self: Generic4) -> Generic4: ...\n-248 +     def __enter__(self) -> typing.Self: ...\n-249 | \n-250 | from some_module import PotentialTypeVar\n-251 | \n+261 +     def __enter__(self) -> typing.Self: ...\n+262 | \n+263 | from some_module import PotentialTypeVar\n+264 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic5` usually return `self` at runtime\n-   --> PYI034.pyi:253:9\n+   --> PYI034.pyi:266:9\n     |\n-252 | class Generic5(list[PotentialTypeVar]):\n-253 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+265 | class Generic5(list[PotentialTypeVar]):\n+266 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n     |         ^^^^^^^\n-254 |     def __enter__(self: Generic5) -> Generic5: ...\n+267 |     def __enter__(self: Generic5) -> Generic5: ...\n     |\n help: Use `Self` as return type\n-250 | from some_module import PotentialTypeVar\n-251 | \n-252 | class Generic5(list[PotentialTypeVar]):\n+263 | from some_module import PotentialTypeVar\n+264 | \n+265 | class Generic5(list[PotentialTypeVar]):\n     -     def __new__(cls: type[Generic5]) -> Generic5: ...\n-253 +     def __new__(cls) -> typing.Self: ...\n-254 |     def __enter__(self: Generic5) -> Generic5: ...\n-255 | \n-256 | \n+266 +     def __new__(cls) -> typing.Self: ...\n+267 |     def __enter__(self: Generic5) -> Generic5: ...\n+268 | \n+269 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic5` usually return `self` at runtime\n-   --> PYI034.pyi:254:9\n+   --> PYI034.pyi:267:9\n     |\n-252 | class Generic5(list[PotentialTypeVar]):\n-253 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n-254 |     def __enter__(self: Generic5) -> Generic5: ...\n+265 | class Generic5(list[PotentialTypeVar]):\n+266 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+267 |     def __enter__(self: Generic5) -> Generic5: ...\n     |         ^^^^^^^^^\n     |\n help: Use `Self` as return type\n-251 | \n-252 | class Generic5(list[PotentialTypeVar]):\n-253 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+264 | \n+265 | class Generic5(list[PotentialTypeVar]):\n+266 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n     -     def __enter__(self: Generic5) -> Generic5: ...\n-254 +     def __enter__(self) -> typing.Self: ...\n-255 | \n-256 | \n-257 | # Test case based on issue #20781 - metaclass that triggers IsMetaclass::Maybe\n+267 +     def __enter__(self) -> typing.Self: ...\n+268 | \n+269 | \n+270 | # Test case based on issue #20781 - metaclass that triggers IsMetaclass::Maybe\n note: This is a display-only fix and is likely to be incorrect\n",
  "ground_truth_diff": "diff --git a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\nindex b35efc3c21..37ad3d3706 100644\n--- a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n+++ b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n@@ -385,3 +385,10 @@ class MetaclassInWhichSelfCannotBeUsed7(django.db.models.base.ModelBase):\n class MetaclassInWhichSelfCannotBeUsed8(django.db.models.base.ModelBase):\n     def __new__(cls, name: builtins.str, bases: tuple, attributes: dict, /, **kw) -> MetaclassInWhichSelfCannotBeUsed8:\n         ...\n+\n+\n+class UsesStringizedForwardReferences:\n+    def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\nindex d3b2f75b2d..e74363a446 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n@@ -182,7 +182,7 @@ pub(crate) fn non_self_return_type(\n \n     if is_async {\n         if name == \"__aenter__\"\n-            && is_name(returns, &class_def.name)\n+            && is_name_or_stringized_name(returns, &class_def.name, checker)\n             && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -198,7 +198,7 @@ pub(crate) fn non_self_return_type(\n         return;\n     }\n \n-    if is_name(returns, &class_def.name) {\n+    if is_name_or_stringized_name(returns, &class_def.name, checker) {\n         if matches!(name, \"__enter__\" | \"__new__\") && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -327,6 +327,11 @@ fn is_name(expr: &ast::Expr, name: &str) -> bool {\n     id.as_str() == name\n }\n \n+/// Return `true` if the given expression resolves to the given name,\n+fn is_name_or_stringized_name(expr: &ast::Expr, name: &str, checker: &Checker) -> bool {\n+    checker.match_maybe_stringized_annotation(expr, |expr| is_name(expr, name))\n+}\n+\n /// Return `true` if the given expression resolves to `typing.Self`.\n fn is_self(expr: &ast::Expr, checker: &Checker) -> bool {\n     checker.match_maybe_stringized_annotation(expr, |expr| {\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\nindex 8893a346e1..c730e8a2b6 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n@@ -472,3 +472,77 @@ help: Use `Self` as return type\n 362 | \n 363 | # Test cases based on issue #20781 - metaclasses that triggers IsMetaclass::Maybe\n note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__new__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:391:9\n+    |\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    |         ^^^^^^^\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+388 | \n+389 | \n+390 | class UsesStringizedForwardReferences:\n+    -     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+391 +     def __new__(cls) -> typing.Self: ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__enter__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:392:9\n+    |\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    |         ^^^^^^^^^\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+389 | \n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    -     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+392 +     def __enter__(self) -> typing.Self: ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__aenter__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:393:15\n+    |\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |               ^^^^^^^^^^\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    -     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+393 +     async def __aenter__(self) -> typing.Self: ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__iadd__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:394:9\n+    |\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |         ^^^^^^^^\n+    |\n+help: Use `Self` as return type\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    -     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 +     def __iadd__(self, other) -> typing.Self: ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n",
  "project_metadata": {
    "CSS": {
      "files": 3,
      "lines": 377,
      "code": 322,
      "comments": 6,
      "blanks": 49
    },
    "Dockerfile": {
      "files": 1,
      "lines": 38,
      "code": 26,
      "comments": 7,
      "blanks": 5
    },
    "HTML": {
      "files": 2,
      "lines": 81,
      "code": 81,
      "comments": 0,
      "blanks": 0
    },
    "JavaScript": {
      "files": 2,
      "lines": 97,
      "code": 77,
      "comments": 11,
      "blanks": 9
    },
    "JSON": {
      "files": 134,
      "lines": 15716,
      "code": 15706,
      "comments": 0,
      "blanks": 10
    },
    "Jupyter Notebooks": {
      "files": 35,
      "lines": 511,
      "code": 289,
      "comments": 154,
      "blanks": 68
    },
    "Markdown": {
      "files": 391,
      "lines": 117506,
      "code": 0,
      "comments": 85634,
      "blanks": 31872
    },
    "Python": {
      "files": 3687,
      "lines": 266549,
      "code": 211732,
      "comments": 12788,
      "blanks": 42029
    },
    "Rust": {
      "files": 1743,
      "lines": 511275,
      "code": 432571,
      "comments": 25123,
      "blanks": 53581
    },
    "Shell": {
      "files": 15,
      "lines": 489,
      "code": 274,
      "comments": 143,
      "blanks": 72
    },
    "SVG": {
      "files": 28,
      "lines": 1445,
      "code": 1308,
      "comments": 71,
      "blanks": 66
    },
    "Plain Text": {
      "files": 43,
      "lines": 188649,
      "code": 0,
      "comments": 188648,
      "blanks": 1
    },
    "TOML": {
      "files": 144,
      "lines": 4323,
      "code": 3625,
      "comments": 219,
      "blanks": 479
    },
    "TSX": {
      "files": 30,
      "lines": 5526,
      "code": 4810,
      "comments": 163,
      "blanks": 553
    },
    "TypeScript": {
      "files": 14,
      "lines": 480,
      "code": 363,
      "comments": 61,
      "blanks": 56
    },
    "YAML": {
      "files": 24,
      "lines": 3705,
      "code": 3093,
      "comments": 288,
      "blanks": 324
    },
    "Total": {
      "files": 0,
      "lines": 1195029,
      "code": 687056,
      "comments": 364538,
      "blanks": 143435
    }
  },
  "bobbin_metadata": null,
  "run_id": "20260210-202731-03b7"
}