{
  "task_id": "ruff-004",
  "approach": "with-bobbin",
  "attempt": 0,
  "status": "completed",
  "timestamp": "2026-02-11T00:28:03.011789+00:00",
  "task": {
    "repo": "astral-sh/ruff",
    "commit": "ceb876b82300bd237d11e3eb77c46fcf3d3afe85",
    "test_command": "cargo test -p ruff_linter -- PYI034",
    "language": "rust",
    "difficulty": "easy"
  },
  "agent_config": {
    "model": "claude-opus-4-6",
    "budget_usd": 100.0,
    "timeout_seconds": 3600,
    "index_timeout_seconds": 600
  },
  "agent_result": {
    "exit_code": 0,
    "duration_seconds": 200.86,
    "timed_out": false
  },
  "test_result": {
    "passed": true,
    "total": 0,
    "failures": 0,
    "parsed": {
      "framework": "pytest",
      "passed": 0,
      "failed": 0,
      "skipped": 0,
      "total": 0
    }
  },
  "diff_result": {
    "file_precision": 0.6,
    "file_recall": 1.0,
    "f1": 0.75,
    "files_touched": [
      "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py",
      "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi",
      "crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs",
      "crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap",
      "crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap"
    ],
    "ground_truth_files": [
      "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py",
      "crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs",
      "crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap"
    ],
    "exact_file_match": false
  },
  "agent_diff": "diff --git a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\nindex b35efc3c21..5699eec632 100644\n--- a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n+++ b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n@@ -323,6 +323,17 @@ class UsesStringizedAnnotations:\n         return self\n \n \n+class BadUsesStringizedAnnotations:\n+    def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+        ...\n+\n+    def __enter__(self) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+        ...\n+\n+    async def __aenter__(self) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+        ...\n+\n+\n class NonGeneric1(tuple):\n     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\ndiff --git a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi\nindex b22f76798b..488df289db 100644\n--- a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi\n+++ b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.pyi\n@@ -216,6 +216,11 @@ def __imul__(self, other: Any) -> list[str]: ...\n class UsesStringizedAnnotations:\n     def __iadd__(self, other: \"UsesStringizedAnnotations\") -> \"typing.Self\": ...\n \n+class BadUsesStringizedAnnotations:\n+    def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+    def __enter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+    async def __aenter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+\n \n class NonGeneric1(tuple):\n     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\nindex d3b2f75b2d..394e6a0b86 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n@@ -182,7 +182,7 @@ pub(crate) fn non_self_return_type(\n \n     if is_async {\n         if name == \"__aenter__\"\n-            && is_name(returns, &class_def.name)\n+            && is_name_or_stringized_name(returns, &class_def.name, checker)\n             && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -198,7 +198,7 @@ pub(crate) fn non_self_return_type(\n         return;\n     }\n \n-    if is_name(returns, &class_def.name) {\n+    if is_name_or_stringized_name(returns, &class_def.name, checker) {\n         if matches!(name, \"__enter__\" | \"__new__\") && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -327,6 +327,12 @@ fn is_name(expr: &ast::Expr, name: &str) -> bool {\n     id.as_str() == name\n }\n \n+/// Return `true` if the given expression resolves to the given name,\n+/// handling both plain and stringized annotations (forward references).\n+fn is_name_or_stringized_name(expr: &ast::Expr, name: &str, checker: &Checker) -> bool {\n+    checker.match_maybe_stringized_annotation(expr, |expr| is_name(expr, name))\n+}\n+\n /// Return `true` if the given expression resolves to `typing.Self`.\n fn is_self(expr: &ast::Expr, checker: &Checker) -> bool {\n     checker.match_maybe_stringized_annotation(expr, |expr| {\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\nindex 8893a346e1..3315914c04 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n@@ -217,258 +217,317 @@ help: Use `Self` as return type\n 206 | class AsyncIteratorReturningAsyncIterable:\n note: This is an unsafe fix and may change runtime behavior\n \n-PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime\n+PYI034 [*] `__new__` methods in classes like `BadUsesStringizedAnnotations` usually return `self` at runtime\n    --> PYI034.py:327:9\n     |\n-326 | class NonGeneric1(tuple):\n-327 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+326 | class BadUsesStringizedAnnotations:\n+327 |     def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\":  # PYI034\n     |         ^^^^^^^\n-328 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+328 |         ...\n     |\n help: Use `Self` as return type\n 324 | \n 325 | \n-326 | class NonGeneric1(tuple):\n-    -     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n-327 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...\n-328 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+326 | class BadUsesStringizedAnnotations:\n+    -     def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+327 +     def __new__(cls, *args: Any, **kwargs: Any) -> typing.Self:  # PYI034\n+328 |         ...\n 329 | \n-330 | class NonGeneric2(tuple):\n+330 |     def __enter__(self) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__enter__` methods in classes like `BadUsesStringizedAnnotations` usually return `self` at runtime\n+   --> PYI034.py:330:9\n+    |\n+328 |         ...\n+329 |\n+330 |     def __enter__(self) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+    |         ^^^^^^^^^\n+331 |         ...\n+    |\n+help: Use `Self` as return type\n+327 |     def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+328 |         ...\n+329 | \n+    -     def __enter__(self) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+330 +     def __enter__(self) -> typing.Self:  # PYI034\n+331 |         ...\n+332 | \n+333 |     async def __aenter__(self) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__aenter__` methods in classes like `BadUsesStringizedAnnotations` usually return `self` at runtime\n+   --> PYI034.py:333:15\n+    |\n+331 |         ...\n+332 |\n+333 |     async def __aenter__(self) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+    |               ^^^^^^^^^^\n+334 |         ...\n+    |\n+help: Use `Self` as return type\n+330 |     def __enter__(self) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+331 |         ...\n+332 | \n+    -     async def __aenter__(self) -> \"BadUsesStringizedAnnotations\":  # PYI034\n+333 +     async def __aenter__(self) -> typing.Self:  # PYI034\n+334 |         ...\n+335 | \n+336 | \n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime\n+   --> PYI034.py:338:9\n+    |\n+337 | class NonGeneric1(tuple):\n+338 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+    |         ^^^^^^^\n+339 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+    |\n+help: Use `Self` as return type\n+335 | \n+336 | \n+337 | class NonGeneric1(tuple):\n+    -     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+338 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...\n+339 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+340 | \n+341 | class NonGeneric2(tuple):\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__enter__` methods in classes like `NonGeneric1` usually return `self` at runtime\n-   --> PYI034.py:328:9\n+   --> PYI034.py:339:9\n     |\n-326 | class NonGeneric1(tuple):\n-327 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n-328 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+337 | class NonGeneric1(tuple):\n+338 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+339 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n     |         ^^^^^^^^^\n-329 |\n-330 | class NonGeneric2(tuple):\n+340 |\n+341 | class NonGeneric2(tuple):\n     |\n help: Use `Self` as return type\n-325 | \n-326 | class NonGeneric1(tuple):\n-327 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+336 | \n+337 | class NonGeneric1(tuple):\n+338 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n     -     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-328 +     def __enter__(self) -> typing.Self: ...\n-329 | \n-330 | class NonGeneric2(tuple):\n-331 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+339 +     def __enter__(self) -> typing.Self: ...\n+340 | \n+341 | class NonGeneric2(tuple):\n+342 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__new__` methods in classes like `NonGeneric2` usually return `self` at runtime\n-   --> PYI034.py:331:9\n+   --> PYI034.py:342:9\n     |\n-330 | class NonGeneric2(tuple):\n-331 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+341 | class NonGeneric2(tuple):\n+342 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n     |         ^^^^^^^\n-332 |\n-333 | class Generic1[T](list):\n+343 |\n+344 | class Generic1[T](list):\n     |\n help: Use `Self` as return type\n-328 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-329 | \n-330 | class NonGeneric2(tuple):\n+339 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+340 | \n+341 | class NonGeneric2(tuple):\n     -     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n-331 +     def __new__(cls) -> typing.Self: ...\n-332 | \n-333 | class Generic1[T](list):\n-334 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+342 +     def __new__(cls) -> typing.Self: ...\n+343 | \n+344 | class Generic1[T](list):\n+345 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__new__` methods in classes like `Generic1` usually return `self` at runtime\n-   --> PYI034.py:334:9\n+   --> PYI034.py:345:9\n     |\n-333 | class Generic1[T](list):\n-334 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+344 | class Generic1[T](list):\n+345 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n     |         ^^^^^^^\n-335 |     def __enter__(self: Generic1) -> Generic1: ...\n+346 |     def __enter__(self: Generic1) -> Generic1: ...\n     |\n help: Use `Self` as return type\n-331 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n-332 | \n-333 | class Generic1[T](list):\n+342 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+343 | \n+344 | class Generic1[T](list):\n     -     def __new__(cls: type[Generic1]) -> Generic1: ...\n-334 +     def __new__(cls) -> typing.Self: ...\n-335 |     def __enter__(self: Generic1) -> Generic1: ...\n-336 | \n-337 | \n+345 +     def __new__(cls) -> typing.Self: ...\n+346 |     def __enter__(self: Generic1) -> Generic1: ...\n+347 | \n+348 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic1` usually return `self` at runtime\n-   --> PYI034.py:335:9\n+   --> PYI034.py:346:9\n     |\n-333 | class Generic1[T](list):\n-334 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n-335 |     def __enter__(self: Generic1) -> Generic1: ...\n+344 | class Generic1[T](list):\n+345 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+346 |     def __enter__(self: Generic1) -> Generic1: ...\n     |         ^^^^^^^^^\n     |\n help: Use `Self` as return type\n-332 | \n-333 | class Generic1[T](list):\n-334 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+343 | \n+344 | class Generic1[T](list):\n+345 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n     -     def __enter__(self: Generic1) -> Generic1: ...\n-335 +     def __enter__(self) -> typing.Self: ...\n-336 | \n-337 | \n-338 | ### Correctness of typevar-likes are not verified.\n+346 +     def __enter__(self) -> typing.Self: ...\n+347 | \n+348 | \n+349 | ### Correctness of typevar-likes are not verified.\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic2` usually return `self` at runtime\n-   --> PYI034.py:345:9\n+   --> PYI034.py:356:9\n     |\n-344 | class Generic2(Generic[T]):\n-345 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+355 | class Generic2(Generic[T]):\n+356 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n     |         ^^^^^^^\n-346 |     def __enter__(self: Generic2) -> Generic2: ...\n+357 |     def __enter__(self: Generic2) -> Generic2: ...\n     |\n help: Use `Self` as return type\n-342 | Ts = TypeVarTuple('foo')\n-343 | \n-344 | class Generic2(Generic[T]):\n+353 | Ts = TypeVarTuple('foo')\n+354 | \n+355 | class Generic2(Generic[T]):\n     -     def __new__(cls: type[Generic2]) -> Generic2: ...\n-345 +     def __new__(cls) -> typing.Self: ...\n-346 |     def __enter__(self: Generic2) -> Generic2: ...\n-347 | \n-348 | class Generic3(tuple[*Ts]):\n+356 +     def __new__(cls) -> typing.Self: ...\n+357 |     def __enter__(self: Generic2) -> Generic2: ...\n+358 | \n+359 | class Generic3(tuple[*Ts]):\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic2` usually return `self` at runtime\n-   --> PYI034.py:346:9\n+   --> PYI034.py:357:9\n     |\n-344 | class Generic2(Generic[T]):\n-345 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n-346 |     def __enter__(self: Generic2) -> Generic2: ...\n+355 | class Generic2(Generic[T]):\n+356 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+357 |     def __enter__(self: Generic2) -> Generic2: ...\n     |         ^^^^^^^^^\n-347 |\n-348 | class Generic3(tuple[*Ts]):\n+358 |\n+359 | class Generic3(tuple[*Ts]):\n     |\n help: Use `Self` as return type\n-343 | \n-344 | class Generic2(Generic[T]):\n-345 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+354 | \n+355 | class Generic2(Generic[T]):\n+356 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n     -     def __enter__(self: Generic2) -> Generic2: ...\n-346 +     def __enter__(self) -> typing.Self: ...\n-347 | \n-348 | class Generic3(tuple[*Ts]):\n-349 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+357 +     def __enter__(self) -> typing.Self: ...\n+358 | \n+359 | class Generic3(tuple[*Ts]):\n+360 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic3` usually return `self` at runtime\n-   --> PYI034.py:349:9\n+   --> PYI034.py:360:9\n     |\n-348 | class Generic3(tuple[*Ts]):\n-349 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+359 | class Generic3(tuple[*Ts]):\n+360 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n     |         ^^^^^^^\n-350 |     def __enter__(self: Generic3) -> Generic3: ...\n+361 |     def __enter__(self: Generic3) -> Generic3: ...\n     |\n help: Use `Self` as return type\n-346 |     def __enter__(self: Generic2) -> Generic2: ...\n-347 | \n-348 | class Generic3(tuple[*Ts]):\n+357 |     def __enter__(self: Generic2) -> Generic2: ...\n+358 | \n+359 | class Generic3(tuple[*Ts]):\n     -     def __new__(cls: type[Generic3]) -> Generic3: ...\n-349 +     def __new__(cls) -> typing.Self: ...\n-350 |     def __enter__(self: Generic3) -> Generic3: ...\n-351 | \n-352 | class Generic4(collections.abc.Callable[P, ...]):\n+360 +     def __new__(cls) -> typing.Self: ...\n+361 |     def __enter__(self: Generic3) -> Generic3: ...\n+362 | \n+363 | class Generic4(collections.abc.Callable[P, ...]):\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic3` usually return `self` at runtime\n-   --> PYI034.py:350:9\n+   --> PYI034.py:361:9\n     |\n-348 | class Generic3(tuple[*Ts]):\n-349 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n-350 |     def __enter__(self: Generic3) -> Generic3: ...\n+359 | class Generic3(tuple[*Ts]):\n+360 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+361 |     def __enter__(self: Generic3) -> Generic3: ...\n     |         ^^^^^^^^^\n-351 |\n-352 | class Generic4(collections.abc.Callable[P, ...]):\n+362 |\n+363 | class Generic4(collections.abc.Callable[P, ...]):\n     |\n help: Use `Self` as return type\n-347 | \n-348 | class Generic3(tuple[*Ts]):\n-349 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+358 | \n+359 | class Generic3(tuple[*Ts]):\n+360 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n     -     def __enter__(self: Generic3) -> Generic3: ...\n-350 +     def __enter__(self) -> typing.Self: ...\n-351 | \n-352 | class Generic4(collections.abc.Callable[P, ...]):\n-353 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+361 +     def __enter__(self) -> typing.Self: ...\n+362 | \n+363 | class Generic4(collections.abc.Callable[P, ...]):\n+364 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic4` usually return `self` at runtime\n-   --> PYI034.py:353:9\n+   --> PYI034.py:364:9\n     |\n-352 | class Generic4(collections.abc.Callable[P, ...]):\n-353 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+363 | class Generic4(collections.abc.Callable[P, ...]):\n+364 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n     |         ^^^^^^^\n-354 |     def __enter__(self: Generic4) -> Generic4: ...\n+365 |     def __enter__(self: Generic4) -> Generic4: ...\n     |\n help: Use `Self` as return type\n-350 |     def __enter__(self: Generic3) -> Generic3: ...\n-351 | \n-352 | class Generic4(collections.abc.Callable[P, ...]):\n+361 |     def __enter__(self: Generic3) -> Generic3: ...\n+362 | \n+363 | class Generic4(collections.abc.Callable[P, ...]):\n     -     def __new__(cls: type[Generic4]) -> Generic4: ...\n-353 +     def __new__(cls) -> typing.Self: ...\n-354 |     def __enter__(self: Generic4) -> Generic4: ...\n-355 | \n-356 | from some_module import PotentialTypeVar\n+364 +     def __new__(cls) -> typing.Self: ...\n+365 |     def __enter__(self: Generic4) -> Generic4: ...\n+366 | \n+367 | from some_module import PotentialTypeVar\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic4` usually return `self` at runtime\n-   --> PYI034.py:354:9\n+   --> PYI034.py:365:9\n     |\n-352 | class Generic4(collections.abc.Callable[P, ...]):\n-353 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n-354 |     def __enter__(self: Generic4) -> Generic4: ...\n+363 | class Generic4(collections.abc.Callable[P, ...]):\n+364 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+365 |     def __enter__(self: Generic4) -> Generic4: ...\n     |         ^^^^^^^^^\n-355 |\n-356 | from some_module import PotentialTypeVar\n+366 |\n+367 | from some_module import PotentialTypeVar\n     |\n help: Use `Self` as return type\n-351 | \n-352 | class Generic4(collections.abc.Callable[P, ...]):\n-353 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+362 | \n+363 | class Generic4(collections.abc.Callable[P, ...]):\n+364 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n     -     def __enter__(self: Generic4) -> Generic4: ...\n-354 +     def __enter__(self) -> typing.Self: ...\n-355 | \n-356 | from some_module import PotentialTypeVar\n-357 | \n+365 +     def __enter__(self) -> typing.Self: ...\n+366 | \n+367 | from some_module import PotentialTypeVar\n+368 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic5` usually return `self` at runtime\n-   --> PYI034.py:359:9\n+   --> PYI034.py:370:9\n     |\n-358 | class Generic5(list[PotentialTypeVar]):\n-359 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+369 | class Generic5(list[PotentialTypeVar]):\n+370 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n     |         ^^^^^^^\n-360 |     def __enter__(self: Generic5) -> Generic5: ...\n+371 |     def __enter__(self: Generic5) -> Generic5: ...\n     |\n help: Use `Self` as return type\n-356 | from some_module import PotentialTypeVar\n-357 | \n-358 | class Generic5(list[PotentialTypeVar]):\n+367 | from some_module import PotentialTypeVar\n+368 | \n+369 | class Generic5(list[PotentialTypeVar]):\n     -     def __new__(cls: type[Generic5]) -> Generic5: ...\n-359 +     def __new__(cls) -> typing.Self: ...\n-360 |     def __enter__(self: Generic5) -> Generic5: ...\n-361 | \n-362 | \n+370 +     def __new__(cls) -> typing.Self: ...\n+371 |     def __enter__(self: Generic5) -> Generic5: ...\n+372 | \n+373 | \n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__enter__` methods in classes like `Generic5` usually return `self` at runtime\n-   --> PYI034.py:360:9\n+   --> PYI034.py:371:9\n     |\n-358 | class Generic5(list[PotentialTypeVar]):\n-359 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n-360 |     def __enter__(self: Generic5) -> Generic5: ...\n+369 | class Generic5(list[PotentialTypeVar]):\n+370 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+371 |     def __enter__(self: Generic5) -> Generic5: ...\n     |         ^^^^^^^^^\n     |\n help: Use `Self` as return type\n-357 | \n-358 | class Generic5(list[PotentialTypeVar]):\n-359 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+368 | \n+369 | class Generic5(list[PotentialTypeVar]):\n+370 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n     -     def __enter__(self: Generic5) -> Generic5: ...\n-360 +     def __enter__(self) -> typing.Self: ...\n-361 | \n-362 | \n-363 | # Test cases based on issue #20781 - metaclasses that triggers IsMetaclass::Maybe\n+371 +     def __enter__(self) -> typing.Self: ...\n+372 | \n+373 | \n+374 | # Test cases based on issue #20781 - metaclasses that triggers IsMetaclass::Maybe\n note: This is an unsafe fix and may change runtime behavior\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap\nindex 29c91b9a77..e24299e8bf 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.pyi.snap\n@@ -198,258 +198,317 @@ help: Use `Self` as return type\n 149 |     def __aiter__(\n note: This is an unsafe fix and may change runtime behavior\n \n-PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime\n-   --> PYI034.pyi:221:9\n+PYI034 [*] `__new__` methods in classes like `BadUsesStringizedAnnotations` usually return `self` at runtime\n+   --> PYI034.pyi:220:9\n     |\n-220 | class NonGeneric1(tuple):\n-221 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+219 | class BadUsesStringizedAnnotations:\n+220 |     def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n     |         ^^^^^^^\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+221 |     def __enter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+222 |     async def __aenter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n     |\n help: Use `Self` as return type\n+217 |     def __iadd__(self, other: \"UsesStringizedAnnotations\") -> \"typing.Self\": ...\n 218 | \n-219 | \n-220 | class NonGeneric1(tuple):\n-    -     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n-221 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+219 | class BadUsesStringizedAnnotations:\n+    -     def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+220 +     def __new__(cls, *args: Any, **kwargs: Any) -> typing.Self: ...  # PYI034\n+221 |     def __enter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+222 |     async def __aenter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+223 | \n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__enter__` methods in classes like `BadUsesStringizedAnnotations` usually return `self` at runtime\n+   --> PYI034.pyi:221:9\n+    |\n+219 | class BadUsesStringizedAnnotations:\n+220 |     def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+221 |     def __enter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+    |         ^^^^^^^^^\n+222 |     async def __aenter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+218 | \n+219 | class BadUsesStringizedAnnotations:\n+220 |     def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+    -     def __enter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+221 +     def __enter__(self) -> typing.Self: ...  # PYI034\n+222 |     async def __aenter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n 223 | \n-224 | class NonGeneric2(tuple):\n+224 | \n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__aenter__` methods in classes like `BadUsesStringizedAnnotations` usually return `self` at runtime\n+   --> PYI034.pyi:222:15\n+    |\n+220 |     def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+221 |     def __enter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+222 |     async def __aenter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+    |               ^^^^^^^^^^\n+    |\n+help: Use `Self` as return type\n+219 | class BadUsesStringizedAnnotations:\n+220 |     def __new__(cls, *args: Any, **kwargs: Any) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+221 |     def __enter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+    -     async def __aenter__(self) -> \"BadUsesStringizedAnnotations\": ...  # PYI034\n+222 +     async def __aenter__(self) -> typing.Self: ...  # PYI034\n+223 | \n+224 | \n+225 | class NonGeneric1(tuple):\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__new__` methods in classes like `NonGeneric1` usually return `self` at runtime\n+   --> PYI034.pyi:226:9\n+    |\n+225 | class NonGeneric1(tuple):\n+226 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+    |         ^^^^^^^\n+227 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+    |\n+help: Use `Self` as return type\n+223 | \n+224 | \n+225 | class NonGeneric1(tuple):\n+    -     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+226 +     def __new__(cls, *args, **kwargs) -> typing.Self: ...\n+227 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+228 | \n+229 | class NonGeneric2(tuple):\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__enter__` methods in classes like `NonGeneric1` usually return `self` at runtime\n-   --> PYI034.pyi:222:9\n+   --> PYI034.pyi:227:9\n     |\n-220 | class NonGeneric1(tuple):\n-221 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+225 | class NonGeneric1(tuple):\n+226 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+227 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n     |         ^^^^^^^^^\n-223 |\n-224 | class NonGeneric2(tuple):\n+228 |\n+229 | class NonGeneric2(tuple):\n     |\n help: Use `Self` as return type\n-219 | \n-220 | class NonGeneric1(tuple):\n-221 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n+224 | \n+225 | class NonGeneric1(tuple):\n+226 |     def __new__(cls: type[NonGeneric1], *args, **kwargs) -> NonGeneric1: ...\n     -     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-222 +     def __enter__(self) -> typing.Self: ...\n-223 | \n-224 | class NonGeneric2(tuple):\n-225 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+227 +     def __enter__(self) -> typing.Self: ...\n+228 | \n+229 | class NonGeneric2(tuple):\n+230 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__new__` methods in classes like `NonGeneric2` usually return `self` at runtime\n-   --> PYI034.pyi:225:9\n+   --> PYI034.pyi:230:9\n     |\n-224 | class NonGeneric2(tuple):\n-225 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n+229 | class NonGeneric2(tuple):\n+230 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n     |         ^^^^^^^\n-226 |\n-227 | class Generic1[T](list):\n+231 |\n+232 | class Generic1[T](list):\n     |\n help: Use `Self` as return type\n-222 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n-223 | \n-224 | class NonGeneric2(tuple):\n+227 |     def __enter__(self: NonGeneric1) -> NonGeneric1: ...\n+228 | \n+229 | class NonGeneric2(tuple):\n     -     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n-225 +     def __new__(cls) -> typing.Self: ...\n-226 | \n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+230 +     def __new__(cls) -> typing.Self: ...\n+231 | \n+232 | class Generic1[T](list):\n+233 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n note: This is an unsafe fix and may change runtime behavior\n \n PYI034 [*] `__new__` methods in classes like `Generic1` usually return `self` at runtime\n-   --> PYI034.pyi:228:9\n+   --> PYI034.pyi:233:9\n     |\n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+232 | class Generic1[T](list):\n+233 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n     |         ^^^^^^^\n-229 |     def __enter__(self: Generic1) -> Generic1: ...\n+234 |     def __enter__(self: Generic1) -> Generic1: ...\n     |\n help: Use `Self` as return type\n-225 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n-226 | \n-227 | class Generic1[T](list):\n-    -     def __new__(cls: type[Generic1]) -> Generic1: ...\n-228 +     def __new__(cls) -> typing.Self: ...\n-229 |     def __enter__(self: Generic1) -> Generic1: ...\n-230 | \n+230 |     def __new__(cls: Type[NonGeneric2]) -> NonGeneric2: ...\n 231 | \n+232 | class Generic1[T](list):\n+    -     def __new__(cls: type[Generic1]) -> Generic1: ...\n+233 +     def __new__(cls) -> typing.Self: ...\n+234 |     def __enter__(self: Generic1) -> Generic1: ...\n+235 | \n+236 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic1` usually return `self` at runtime\n-   --> PYI034.pyi:229:9\n+   --> PYI034.pyi:234:9\n     |\n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n-229 |     def __enter__(self: Generic1) -> Generic1: ...\n+232 | class Generic1[T](list):\n+233 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+234 |     def __enter__(self: Generic1) -> Generic1: ...\n     |         ^^^^^^^^^\n     |\n help: Use `Self` as return type\n-226 | \n-227 | class Generic1[T](list):\n-228 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n-    -     def __enter__(self: Generic1) -> Generic1: ...\n-229 +     def __enter__(self) -> typing.Self: ...\n-230 | \n 231 | \n-232 | ### Correctness of typevar-likes are not verified.\n+232 | class Generic1[T](list):\n+233 |     def __new__(cls: type[Generic1]) -> Generic1: ...\n+    -     def __enter__(self: Generic1) -> Generic1: ...\n+234 +     def __enter__(self) -> typing.Self: ...\n+235 | \n+236 | \n+237 | ### Correctness of typevar-likes are not verified.\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic2` usually return `self` at runtime\n-   --> PYI034.pyi:239:9\n+   --> PYI034.pyi:244:9\n     |\n-238 | class Generic2(Generic[T]):\n-239 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+243 | class Generic2(Generic[T]):\n+244 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n     |         ^^^^^^^\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n+245 |     def __enter__(self: Generic2) -> Generic2: ...\n     |\n help: Use `Self` as return type\n-236 | Ts = TypeVarTuple('foo')\n-237 | \n-238 | class Generic2(Generic[T]):\n+241 | Ts = TypeVarTuple('foo')\n+242 | \n+243 | class Generic2(Generic[T]):\n     -     def __new__(cls: type[Generic2]) -> Generic2: ...\n-239 +     def __new__(cls) -> typing.Self: ...\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n+244 +     def __new__(cls) -> typing.Self: ...\n+245 |     def __enter__(self: Generic2) -> Generic2: ...\n+246 | \n+247 | class Generic3(tuple[*Ts]):\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic2` usually return `self` at runtime\n-   --> PYI034.pyi:240:9\n+   --> PYI034.pyi:245:9\n     |\n-238 | class Generic2(Generic[T]):\n-239 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n+243 | class Generic2(Generic[T]):\n+244 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+245 |     def __enter__(self: Generic2) -> Generic2: ...\n     |         ^^^^^^^^^\n-241 |\n-242 | class Generic3(tuple[*Ts]):\n+246 |\n+247 | class Generic3(tuple[*Ts]):\n     |\n help: Use `Self` as return type\n-237 | \n-238 | class Generic2(Generic[T]):\n-239 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n+242 | \n+243 | class Generic2(Generic[T]):\n+244 |     def __new__(cls: type[Generic2]) -> Generic2: ...\n     -     def __enter__(self: Generic2) -> Generic2: ...\n-240 +     def __enter__(self) -> typing.Self: ...\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+245 +     def __enter__(self) -> typing.Self: ...\n+246 | \n+247 | class Generic3(tuple[*Ts]):\n+248 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic3` usually return `self` at runtime\n-   --> PYI034.pyi:243:9\n+   --> PYI034.pyi:248:9\n     |\n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+247 | class Generic3(tuple[*Ts]):\n+248 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n     |         ^^^^^^^\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n+249 |     def __enter__(self: Generic3) -> Generic3: ...\n     |\n help: Use `Self` as return type\n-240 |     def __enter__(self: Generic2) -> Generic2: ...\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n+245 |     def __enter__(self: Generic2) -> Generic2: ...\n+246 | \n+247 | class Generic3(tuple[*Ts]):\n     -     def __new__(cls: type[Generic3]) -> Generic3: ...\n-243 +     def __new__(cls) -> typing.Self: ...\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n+248 +     def __new__(cls) -> typing.Self: ...\n+249 |     def __enter__(self: Generic3) -> Generic3: ...\n+250 | \n+251 | class Generic4(collections.abc.Callable[P, ...]):\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic3` usually return `self` at runtime\n-   --> PYI034.pyi:244:9\n+   --> PYI034.pyi:249:9\n     |\n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n+247 | class Generic3(tuple[*Ts]):\n+248 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+249 |     def __enter__(self: Generic3) -> Generic3: ...\n     |         ^^^^^^^^^\n-245 |\n-246 | class Generic4(collections.abc.Callable[P, ...]):\n+250 |\n+251 | class Generic4(collections.abc.Callable[P, ...]):\n     |\n help: Use `Self` as return type\n-241 | \n-242 | class Generic3(tuple[*Ts]):\n-243 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n+246 | \n+247 | class Generic3(tuple[*Ts]):\n+248 |     def __new__(cls: type[Generic3]) -> Generic3: ...\n     -     def __enter__(self: Generic3) -> Generic3: ...\n-244 +     def __enter__(self) -> typing.Self: ...\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+249 +     def __enter__(self) -> typing.Self: ...\n+250 | \n+251 | class Generic4(collections.abc.Callable[P, ...]):\n+252 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic4` usually return `self` at runtime\n-   --> PYI034.pyi:247:9\n+   --> PYI034.pyi:252:9\n     |\n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+251 | class Generic4(collections.abc.Callable[P, ...]):\n+252 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n     |         ^^^^^^^\n-248 |     def __enter__(self: Generic4) -> Generic4: ...\n+253 |     def __enter__(self: Generic4) -> Generic4: ...\n     |\n help: Use `Self` as return type\n-244 |     def __enter__(self: Generic3) -> Generic3: ...\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n+249 |     def __enter__(self: Generic3) -> Generic3: ...\n+250 | \n+251 | class Generic4(collections.abc.Callable[P, ...]):\n     -     def __new__(cls: type[Generic4]) -> Generic4: ...\n-247 +     def __new__(cls) -> typing.Self: ...\n-248 |     def __enter__(self: Generic4) -> Generic4: ...\n-249 | \n-250 | from some_module import PotentialTypeVar\n+252 +     def __new__(cls) -> typing.Self: ...\n+253 |     def __enter__(self: Generic4) -> Generic4: ...\n+254 | \n+255 | from some_module import PotentialTypeVar\n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic4` usually return `self` at runtime\n-   --> PYI034.pyi:248:9\n+   --> PYI034.pyi:253:9\n     |\n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n-248 |     def __enter__(self: Generic4) -> Generic4: ...\n+251 | class Generic4(collections.abc.Callable[P, ...]):\n+252 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+253 |     def __enter__(self: Generic4) -> Generic4: ...\n     |         ^^^^^^^^^\n-249 |\n-250 | from some_module import PotentialTypeVar\n+254 |\n+255 | from some_module import PotentialTypeVar\n     |\n help: Use `Self` as return type\n-245 | \n-246 | class Generic4(collections.abc.Callable[P, ...]):\n-247 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n+250 | \n+251 | class Generic4(collections.abc.Callable[P, ...]):\n+252 |     def __new__(cls: type[Generic4]) -> Generic4: ...\n     -     def __enter__(self: Generic4) -> Generic4: ...\n-248 +     def __enter__(self) -> typing.Self: ...\n-249 | \n-250 | from some_module import PotentialTypeVar\n-251 | \n+253 +     def __enter__(self) -> typing.Self: ...\n+254 | \n+255 | from some_module import PotentialTypeVar\n+256 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__new__` methods in classes like `Generic5` usually return `self` at runtime\n-   --> PYI034.pyi:253:9\n+   --> PYI034.pyi:258:9\n     |\n-252 | class Generic5(list[PotentialTypeVar]):\n-253 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+257 | class Generic5(list[PotentialTypeVar]):\n+258 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n     |         ^^^^^^^\n-254 |     def __enter__(self: Generic5) -> Generic5: ...\n+259 |     def __enter__(self: Generic5) -> Generic5: ...\n     |\n help: Use `Self` as return type\n-250 | from some_module import PotentialTypeVar\n-251 | \n-252 | class Generic5(list[PotentialTypeVar]):\n-    -     def __new__(cls: type[Generic5]) -> Generic5: ...\n-253 +     def __new__(cls) -> typing.Self: ...\n-254 |     def __enter__(self: Generic5) -> Generic5: ...\n-255 | \n+255 | from some_module import PotentialTypeVar\n 256 | \n+257 | class Generic5(list[PotentialTypeVar]):\n+    -     def __new__(cls: type[Generic5]) -> Generic5: ...\n+258 +     def __new__(cls) -> typing.Self: ...\n+259 |     def __enter__(self: Generic5) -> Generic5: ...\n+260 | \n+261 | \n note: This is a display-only fix and is likely to be incorrect\n \n PYI034 [*] `__enter__` methods in classes like `Generic5` usually return `self` at runtime\n-   --> PYI034.pyi:254:9\n+   --> PYI034.pyi:259:9\n     |\n-252 | class Generic5(list[PotentialTypeVar]):\n-253 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n-254 |     def __enter__(self: Generic5) -> Generic5: ...\n+257 | class Generic5(list[PotentialTypeVar]):\n+258 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+259 |     def __enter__(self: Generic5) -> Generic5: ...\n     |         ^^^^^^^^^\n     |\n help: Use `Self` as return type\n-251 | \n-252 | class Generic5(list[PotentialTypeVar]):\n-253 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n-    -     def __enter__(self: Generic5) -> Generic5: ...\n-254 +     def __enter__(self) -> typing.Self: ...\n-255 | \n 256 | \n-257 | # Test case based on issue #20781 - metaclass that triggers IsMetaclass::Maybe\n+257 | class Generic5(list[PotentialTypeVar]):\n+258 |     def __new__(cls: type[Generic5]) -> Generic5: ...\n+    -     def __enter__(self: Generic5) -> Generic5: ...\n+259 +     def __enter__(self) -> typing.Self: ...\n+260 | \n+261 | \n+262 | # Test case based on issue #20781 - metaclass that triggers IsMetaclass::Maybe\n note: This is a display-only fix and is likely to be incorrect\n",
  "ground_truth_diff": "diff --git a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\nindex b35efc3c21..37ad3d3706 100644\n--- a/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n+++ b/crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py\n@@ -385,3 +385,10 @@ class MetaclassInWhichSelfCannotBeUsed7(django.db.models.base.ModelBase):\n class MetaclassInWhichSelfCannotBeUsed8(django.db.models.base.ModelBase):\n     def __new__(cls, name: builtins.str, bases: tuple, attributes: dict, /, **kw) -> MetaclassInWhichSelfCannotBeUsed8:\n         ...\n+\n+\n+class UsesStringizedForwardReferences:\n+    def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\nindex d3b2f75b2d..e74363a446 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs\n@@ -182,7 +182,7 @@ pub(crate) fn non_self_return_type(\n \n     if is_async {\n         if name == \"__aenter__\"\n-            && is_name(returns, &class_def.name)\n+            && is_name_or_stringized_name(returns, &class_def.name, checker)\n             && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -198,7 +198,7 @@ pub(crate) fn non_self_return_type(\n         return;\n     }\n \n-    if is_name(returns, &class_def.name) {\n+    if is_name_or_stringized_name(returns, &class_def.name, checker) {\n         if matches!(name, \"__enter__\" | \"__new__\") && !is_final(&class_def.decorator_list, semantic)\n         {\n             add_diagnostic(checker, stmt, returns, class_def, name);\n@@ -327,6 +327,11 @@ fn is_name(expr: &ast::Expr, name: &str) -> bool {\n     id.as_str() == name\n }\n \n+/// Return `true` if the given expression resolves to the given name,\n+fn is_name_or_stringized_name(expr: &ast::Expr, name: &str, checker: &Checker) -> bool {\n+    checker.match_maybe_stringized_annotation(expr, |expr| is_name(expr, name))\n+}\n+\n /// Return `true` if the given expression resolves to `typing.Self`.\n fn is_self(expr: &ast::Expr, checker: &Checker) -> bool {\n     checker.match_maybe_stringized_annotation(expr, |expr| {\ndiff --git a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\nindex 8893a346e1..c730e8a2b6 100644\n--- a/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n+++ b/crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI034_PYI034.py.snap\n@@ -472,3 +472,77 @@ help: Use `Self` as return type\n 362 | \n 363 | # Test cases based on issue #20781 - metaclasses that triggers IsMetaclass::Maybe\n note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__new__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:391:9\n+    |\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    |         ^^^^^^^\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+388 | \n+389 | \n+390 | class UsesStringizedForwardReferences:\n+    -     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+391 +     def __new__(cls) -> typing.Self: ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__enter__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:392:9\n+    |\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    |         ^^^^^^^^^\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+389 | \n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+    -     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+392 +     def __enter__(self) -> typing.Self: ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__aenter__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:393:15\n+    |\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |               ^^^^^^^^^^\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |\n+help: Use `Self` as return type\n+390 | class UsesStringizedForwardReferences:\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+    -     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+393 +     async def __aenter__(self) -> typing.Self: ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n+\n+PYI034 [*] `__iadd__` methods in classes like `UsesStringizedForwardReferences` usually return `self` at runtime\n+   --> PYI034.py:394:9\n+    |\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 |     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    |         ^^^^^^^^\n+    |\n+help: Use `Self` as return type\n+391 |     def __new__(cls) -> \"UsesStringizedForwardReferences\": ...       # PYI034\n+392 |     def __enter__(self) -> \"UsesStringizedForwardReferences\": ...    # PYI034\n+393 |     async def __aenter__(self) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+    -     def __iadd__(self, other) -> \"UsesStringizedForwardReferences\": ...  # PYI034\n+394 +     def __iadd__(self, other) -> typing.Self: ...  # PYI034\n+note: This is an unsafe fix and may change runtime behavior\n",
  "project_metadata": {
    "CSS": {
      "files": 3,
      "lines": 377,
      "code": 322,
      "comments": 6,
      "blanks": 49
    },
    "Dockerfile": {
      "files": 1,
      "lines": 38,
      "code": 26,
      "comments": 7,
      "blanks": 5
    },
    "HTML": {
      "files": 2,
      "lines": 81,
      "code": 81,
      "comments": 0,
      "blanks": 0
    },
    "JavaScript": {
      "files": 2,
      "lines": 97,
      "code": 77,
      "comments": 11,
      "blanks": 9
    },
    "JSON": {
      "files": 134,
      "lines": 15716,
      "code": 15706,
      "comments": 0,
      "blanks": 10
    },
    "Jupyter Notebooks": {
      "files": 35,
      "lines": 511,
      "code": 289,
      "comments": 154,
      "blanks": 68
    },
    "Markdown": {
      "files": 391,
      "lines": 117506,
      "code": 0,
      "comments": 85634,
      "blanks": 31872
    },
    "Python": {
      "files": 3687,
      "lines": 266549,
      "code": 211732,
      "comments": 12788,
      "blanks": 42029
    },
    "Rust": {
      "files": 1743,
      "lines": 511275,
      "code": 432571,
      "comments": 25123,
      "blanks": 53581
    },
    "Shell": {
      "files": 15,
      "lines": 489,
      "code": 274,
      "comments": 143,
      "blanks": 72
    },
    "SVG": {
      "files": 28,
      "lines": 1445,
      "code": 1308,
      "comments": 71,
      "blanks": 66
    },
    "Plain Text": {
      "files": 43,
      "lines": 188649,
      "code": 0,
      "comments": 188648,
      "blanks": 1
    },
    "TOML": {
      "files": 144,
      "lines": 4323,
      "code": 3625,
      "comments": 219,
      "blanks": 479
    },
    "TSX": {
      "files": 30,
      "lines": 5526,
      "code": 4810,
      "comments": 163,
      "blanks": 553
    },
    "TypeScript": {
      "files": 14,
      "lines": 480,
      "code": 363,
      "comments": 61,
      "blanks": 56
    },
    "YAML": {
      "files": 24,
      "lines": 3705,
      "code": 3093,
      "comments": 288,
      "blanks": 324
    },
    "Total": {
      "files": 0,
      "lines": 1195029,
      "code": 687056,
      "comments": 364538,
      "blanks": 143435
    }
  },
  "bobbin_metadata": {
    "index_duration_seconds": 112.39,
    "profile": {
      "file_i/o": 2,
      "parse": 1751,
      "context": 11,
      "embed": 30989,
      "tokenize": 6080,
      "inference": 23226,
      "pooling": 753,
      "lance_delete": 69954,
      "lance_insert": 805,
      "git_coupling": 932,
      "git_commits": 2022,
      "deps": 22,
      "compact": 258,
      "other/overhead": 5381,
      "total_ms": 112127,
      "embed_throughput_chunks_per_sec": 1818.6
    },
    "total_files": null,
    "total_chunks": null,
    "total_embeddings": null,
    "languages": []
  },
  "run_id": "20260211-001827-74b3"
}